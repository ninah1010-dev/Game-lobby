const { useState, useEffect } = React;

// å…±åŒåŠŸèƒ½ï¼šæ´—ç‰Œé™£åˆ—
const shuffleArray = (array) => {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
};

// æ‰€æœ‰éŠæˆ²è³‡æ–™å®šç¾©é›†ä¸­æ–¼æ­¤
const gameData = {
  whosTheSpy: {
    name: 'èª°æ˜¯è‡¥åº•',
    icon: 'ğŸ‘»',
    roles: [
      { name: 'å¹³æ°‘', icon: 'ğŸ‘¤', code: 'civilian', description: 'èˆ‡å…¶ä»–å¹³æ°‘ç²å¾—ç›¸åŒè©èªã€‚', side: 'good' },
      { name: 'è‡¥åº•', icon: 'âš”ï¸', code: 'spy', description: 'ç²å¾—èˆ‡å¹³æ°‘ä¸åŒçš„è©èªã€‚', side: 'evil' },
      { name: 'ç™½æ¿', icon: 'ğŸš«', code: 'blank', description: 'å®Œå…¨æ²’æœ‰è©èªï¼Œéœ€é€éçŒœæ¸¬ä¾†éš±è—èº«åˆ†ã€‚', side: 'neutral' }
    ],
    words: [
      ['ç‰›å¥¶', 'ç¾Šå¥¶'], ['å¯å£å¯æ¨‚', 'ç™¾äº‹å¯æ¨‚'], ['ç­†è¨˜æœ¬', 'è¨˜äº‹æœ¬'],
      ['å†°æ·‡æ·‹', 'é›ªç³•'], ['è¥¿ç“œ', 'å†¬ç“œ'], ['é‰›ç­†', 'åŸå­ç­†'],
      ['æ¼¢å ¡', 'ä¸‰æ˜æ²»'], ['éº»ç³¬', 'æ¹¯åœ“'], ['è‘¡è„æŸš', 'æ©˜å­'],
      ['éºµæ¢', 'æ‹‰éºµ'], ['å¤ªé™½', 'æœˆäº®'], ['æ‰‹æ©Ÿ', 'å¹³æ¿é›»è…¦'],
      ['å†°ç®±', 'å†·æ°£æ©Ÿ'], ['æ£‰èŠ±ç³–', 'æµ·ç¶¿è›‹ç³•'], ['æ´—é¢ä¹³', 'æ²æµ´ä¹³'],
      ['éº¥å…‹é¢¨', 'æ“´éŸ³å™¨'], ['é‘°åŒ™', 'é–é ­'], ['ç•ªèŒ„', 'è‰è“']
    ],
    playerConfigs: {
      4: { civilian: 3, spy: 1 }, 5: { civilian: 4, spy: 1 },
      6: { civilian: 4, spy: 1, blank: 1 },
      7: { civilian: 5, spy: 2 }, 8: { civilian: 6, spy: 2 },
      9: { civilian: 7, spy: 2 }, 10: { civilian: 8, spy: 2 }
    }
  },
  werewolf: {
    name: 'ç‹¼äººæ®º',
    icon: 'ğŸª“',
    roles: [
      { name: 'ç‹¼äºº', icon: 'ğŸª“', code: 'werewolf', description: 'åœ¨å¤œæ™šæ®ºå®³å¹³æ°‘ã€‚', side: 'evil' },
      { name: 'å¹³æ°‘', icon: 'ğŸ‘¤', code: 'civilian', description: 'ç™½å¤©ç™¼è¨€ä¸¦æŠ•ç¥¨æ‰¾å‡ºç‹¼äººã€‚', side: 'good' },
      { name: 'é è¨€å®¶', icon: 'ğŸ‘ï¸', code: 'seer', description: 'æ¯æ™šæŸ¥é©—ä¸€äººèº«åˆ†ã€‚', side: 'good' },
      { name: 'å¥³å·«', icon: 'ğŸ›¡ï¸', code: 'witch', description: 'æœ‰è§£è—¥å’Œæ¯’è—¥å„ä¸€ç“¶ã€‚', side: 'good' },
      { name: 'çµäºº', icon: 'ğŸ¯', code: 'hunter', description: 'æ­»å¾Œå¯ä»¥é–‹æ§å¸¶èµ°ä¸€äººã€‚', side: 'good' },
      { name: 'é‚±æ¯”ç‰¹', icon: 'â¤ï¸', code: 'cupid', description: 'é€£çµå…©äººæˆç‚ºæƒ…ä¾¶ã€‚', side: 'good' },
      { name: 'ç‹¼ç‹', icon: 'ğŸ‘‘', code: 'wolf_king', description: 'æ­»å¾Œå¯ä»¥é–‹æ§å¸¶èµ°ä¸€äººã€‚', side: 'evil' },
      { name: 'å®ˆè¡›', icon: 'ğŸ›¡ï¸âœ…', code: 'guardian', description: 'æ¯æ™šå¯ä»¥å®ˆè­·ä¸€äººã€‚', side: 'good' },
      { name: 'ç™½ç™¡', icon: 'ğŸ›¡ï¸âŒ', code: 'idiot', description: 'è¢«æŠ•ç¥¨å‡ºå±€å¾Œå¯ç¿»ç‰Œå…æ­»ã€‚', side: 'good' }
    ],
    playerConfigs: {
      6: { werewolf: 2, civilian: 2, seer: 1, witch: 1 },
      7: { werewolf: 2, civilian: 3, seer: 1, witch: 1 },
      8: { werewolf: 2, civilian: 3, seer: 1, witch: 1, hunter: 1 },
      9: { werewolf: 3, civilian: 3, seer: 1, witch: 1, hunter: 1 },
      10: { werewolf: 3, civilian: 3, seer: 1, witch: 1, hunter: 1, cupid: 1 },
      12: { werewolf: 4, civilian: 4, seer: 1, witch: 1, hunter: 1, cupid: 1, guardian: 1 },
      14: { werewolf: 4, civilian: 5, seer: 1, witch: 1, hunter: 1, cupid: 1, guardian: 1, idiot: 1 }
    }
  },
  avalon: {
    name: 'é˜¿ç“¦éš†',
    icon: 'ğŸ—¡ï¸',
    roles: [
      { name: 'æ¢…æ—', icon: 'ğŸ‘‘', code: 'merlin', description: 'æ­£ç¾©æ–¹é ˜è¢–ï¼ŒçŸ¥é“é‚ªæƒ¡èº«åˆ†ã€‚', side: 'good' },
      { name: 'åˆºå®¢', icon: 'âš”ï¸', code: 'assassin', description: 'é‚ªæƒ¡æ–¹ï¼Œè‹¥æ­£ç¾©æˆåŠŸå¯åˆºæ®ºæ¢…æ—ã€‚', side: 'evil' },
      { name: 'æ´¾è¥¿ç¶­çˆ¾', icon: 'ğŸ‘ï¸', code: 'percival', description: 'çŸ¥é“æ¢…æ—èˆ‡è«ç”˜å¨œèº«åˆ†ã€‚', side: 'good' },
      { name: 'è«ç”˜å¨œ', icon: 'ğŸ‘»', code: 'morgana', description: 'é‚ªæƒ¡æ–¹ï¼Œå½è£æˆæ¢…æ—ã€‚', side: 'evil' },
      { name: 'å¥§ä¼¯å€«', icon: 'â“', code: 'oberon', description: 'é‚ªæƒ¡æ–¹ï¼Œä½†ä¸çŸ¥é“é‚ªæƒ¡åŒä¼´ã€‚', side: 'evil' },
      { name: 'è«å¾·é›·å¾·', icon: 'ğŸ”’', code: 'mordred', description: 'é‚ªæƒ¡æ–¹ï¼Œæ¢…æ—ç„¡æ³•åµæ¸¬ã€‚', side: 'evil' },
      { name: 'å¿ è‡£', icon: 'ğŸ›¡ï¸âœ…', code: 'servant', description: 'æ­£ç¾©æ–¹ï¼Œå¿ èª æ–¼äºç‘Ÿç‹ã€‚', side: 'good' },
      { name: 'çˆªç‰™', icon: 'ğŸ—¡ï¸', code: 'minion', description: 'é‚ªæƒ¡æ–¹ï¼Œå¿ èª æ–¼è«å¾·é›·å¾·ã€‚', side: 'evil' }
    ],
    playerConfigs: {
      5: { servant: 2, merlin: 1, minion: 1, assassin: 1 },
      6: { servant: 2, merlin: 1, percival: 1, morgana: 1, assassin: 1 },
      7: { servant: 2, merlin: 1, percival: 1, morgana: 1, assassin: 1, oberon: 1 },
      8: { servant: 3, merlin: 1, percival: 1, morgana: 1, assassin: 1, mordred: 1 },
      9: { servant: 4, merlin: 1, percival: 1, morgana: 1, assassin: 1, mordred: 1 },
      10: { servant: 4, merlin: 1, percival: 1, morgana: 1, assassin: 1, mordred: 1, oberon: 1 }
    },
    questSizes: {
      5: [2, 3, 2, 3, 3],
      6: [2, 3, 4, 3, 4],
      7: [2, 3, 3, 4, 4],
      8: [3, 4, 4, 5, 5],
      9: [3, 4, 4, 5, 5],
      10: [3, 4, 4, 5, 5]
    }
  }
};

const getDefaultRoles = (mode, count) => {
  const config = gameData[mode].playerConfigs[count] || {};
  return Object.keys(config).map(roleCode => ({
    code: roleCode,
    count: config[roleCode]
  }));
};

const App = () => {
  const [currentPage, setCurrentPage] = useState('home');
  const [gameMode, setGameMode] = useState(null);
  const [players, setPlayers] = useState([]);
  const [roleCounts, setRoleCounts] = useState({});
  const [playerCount, setPlayerCount] = useState(0);
  const [currentPlayerIndex, setCurrentPlayerIndex] = useState(0);
  const [isCardFlipped, setIsCardFlipped] = useState(false);
  const [message, setMessage] = useState('');
  const [isFetchingWords, setIsFetchingWords] = useState(false);
  const [gameHistory, setGameHistory] = useState([]);
  const [gameResult, setGameResult] = useState('');

  // Avalon specific states
  const [avalonState, setAvalonState] = useState({
    leader: null,
    currentQuest: 0,
    team: [],
    questResults: [],
    voteCount: 0,
    currentVotePhase: 'team-selection',
    questVoteOutcome: null,
    missionVoteTally: { success: 0, fail: 0 },
    assassinationTarget: null,
    failedVotes: 0,
    questTeams: [],
    showQuestTeamModal: false,
    selectedQuestIndex: null
  });

  // Whos the Spy specific states
  const [whosTheSpyState, setWhosTheSpyState] = useState({
    round: 1,
    turn: 0,
    descriptions: {},
    phase: 'describing',
  });

  // Werewolf specific states
  const [werewolfState, setWerewolfState] = useState({
    day: 1,
    phase: 'night-intro',
    killedPlayerId: null,
    poisonedPlayerId: null,
    savedPlayerId: null,
    witchHasAntidote: true,
    witchHasPoison: true,
    werewolfTargetId: null,
    seerTargetId: null,
    seerResult: null,
    guardianTargetId: null,
    killedList: [],
    playersToVote: [],
    votedOutPlayerId: null
  });

  // å¾ localStorage è¼‰å…¥éŠæˆ²æ­·å²ç´€éŒ„
  useEffect(() => {
    try {
      const history = JSON.parse(localStorage.getItem('gameHistory')) || [];
      setGameHistory(history);
    } catch (e) {
      console.error("Failed to load game history from localStorage", e);
    }
  }, []);

  const showMessageWithTimeout = (msg) => {
    setMessage(msg);
    setTimeout(() => setMessage(''), 3000);
  };
  
  const saveGameHistory = (result) => {
    const newHistory = {
        gameMode: gameData[gameMode].name,
        timestamp: new Date().toLocaleString(),
        players: players.map(p => ({ name: p.name, role: gameData[gameMode].roles.find(r => r.code === p.role)?.name })),
        result: result
    };
    const updatedHistory = [newHistory, ...gameHistory];
    setGameHistory(updatedHistory);
    localStorage.setItem('gameHistory', JSON.stringify(updatedHistory));
  };


  const setupGame = (mode) => {
    setGameMode(mode);
    const defaultCount = Object.keys(gameData[mode].playerConfigs)[0];
    setPlayerCount(parseInt(defaultCount));
    updateRoleCounts(mode, parseInt(defaultCount));
    setCurrentPage('setup');
  };

  const updateRoleCounts = (mode, count) => {
    const roles = getDefaultRoles(mode, count);
    const newCounts = {};
    roles.forEach(role => newCounts[role.code] = role.count);
    setRoleCounts(newCounts);
  };

  const handleStartGame = () => {
    const totalPlayers = Object.values(roleCounts).reduce((sum, count) => sum + count, 0);
    if (totalPlayers === 0 || totalPlayers !== playerCount) {
      showMessageWithTimeout('ç¸½äººæ•¸èˆ‡è§’è‰²æ•¸é‡ä¸ç¬¦ï¼');
      return;
    }

    let rolesToAssign = [];
    for (const role in roleCounts) {
      for (let i = 0; i < roleCounts[role]; i++) {
        rolesToAssign.push(role);
      }
    }
    shuffleArray(rolesToAssign);

    const initialPlayers = Array.from({ length: playerCount }, (_, i) => ({
      id: i,
      name: `ç©å®¶ ${i + 1}`,
      role: rolesToAssign[i],
      revealed: false,
      word: null,
      alive: true
    }));

    if (gameMode === 'whosTheSpy') {
      const selectedWords = gameData.whosTheSpy.words[Math.floor(Math.random() * gameData.whosTheSpy.words.length)];
      initialPlayers.forEach(player => {
        if (player.role === 'spy') {
          player.word = selectedWords[1];
        } else if (player.role === 'civilian') {
          player.word = selectedWords[0];
        } else if (player.role === 'blank') {
          player.word = null;
        }
      });
      setWhosTheSpyState({ round: 1, turn: 0, descriptions: {}, phase: 'describing' });
    }

    if (gameMode === 'avalon') {
      const initialLeaderIndex = Math.floor(Math.random() * playerCount);
      setAvalonState({
        ...avalonState,
        leader: initialPlayers[initialLeaderIndex].id,
        currentQuest: 1,
        currentVotePhase: 'team-selection'
      });
    }

    if (gameMode === 'werewolf') {
      setWerewolfState({
        day: 1,
        phase: 'night-intro',
        killedPlayerId: null,
        poisonedPlayerId: null,
        savedPlayerId: null,
        witchHasAntidote: true,
        witchHasPoison: true,
        werewolfTargetId: null,
        seerTargetId: null,
        seerResult: null,
        guardianTargetId: null,
        killedList: [],
        playersToVote: [],
        votedOutPlayerId: null
      });
    }

    setPlayers(initialPlayers);
    setIsCardFlipped(false);
    setCurrentPlayerIndex(0);
    setCurrentPage('role-reveal');
  };

  const nextPlayerReveal = () => {
    setIsCardFlipped(false);
    if (currentPlayerIndex < players.length - 1) {
      setCurrentPlayerIndex(prev => prev + 1);
    } else {
      setCurrentPage(
        gameMode === 'avalon' ? 'avalon-gameplay' :
        gameMode === 'whosTheSpy' ? 'whos-the-spy-gameplay' :
        'werewolf-gameplay'
      );
    }
  };
  
  const getPlayerRoleInfo = (roleCode) => {
    return gameData[gameMode]?.roles.find(r => r.code === roleCode);
  };
  
  const endGame = (result) => {
      setGameResult(result);
      saveGameHistory(result);
      setCurrentPage('result-screen');
  };


  // --- Avalon Logic ---
  const togglePlayerSelection = (playerId) => {
    setAvalonState(prev => {
      const teamSize = gameData.avalon.questSizes[playerCount][prev.currentQuest - 1];
      const newTeam = prev.team.includes(playerId)
        ? prev.team.filter(id => id !== playerId)
        : [...prev.team, playerId];
      if (newTeam.length > teamSize) {
        showMessageWithTimeout(`ä»»å‹™éšŠä¼ä¸Šé™ç‚º ${teamSize} äºº`);
        return prev;
      }
      return { ...prev, team: newTeam };
    });
  };

  const startAvalonTeamVote = () => {
    setAvalonState(prev => ({ ...prev, currentVotePhase: 'team-voting', voteTally: { approve: 0, reject: 0 } }));
    showMessageWithTimeout('é ˜è¢–å·²ç™¼èµ·åœ˜éšŠæŠ•ç¥¨ï¼');
  };

  const recordAvalonTeamVote = (outcome) => {
    setAvalonState(prev => {
      const newTally = { ...prev.voteTally };
      newTally[outcome]++;
      const totalVotes = newTally.approve + newTally.reject;
      const majority = playerCount / 2;
      const isMajority = newTally.approve > majority;

      if (totalVotes === playerCount) {
        if (isMajority) {
          showMessageWithTimeout('åœ˜éšŠæŠ•ç¥¨é€šéï¼æº–å‚™å‡ºç™¼åŸ·è¡Œä»»å‹™ã€‚');
          return {
            ...prev,
            voteTally: newTally,
            currentVotePhase: 'mission-voting',
            failedVotes: 0,
            questTeams: [...(prev.questTeams || []), { quest: prev.currentQuest, members: prev.team }]
          };
        } else {
          showMessageWithTimeout('åœ˜éšŠæŠ•ç¥¨æœªé€šéã€‚æ›´æ›é ˜è¢–ï¼Œé‡æ–°çµ„éšŠã€‚');
          const newLeaderIndex = (players.findIndex(p => p.id === prev.leader) + 1) % playerCount;
          const newFailedVotes = prev.failedVotes + 1;
          if (newFailedVotes >= 5) {
            endGame('é‚ªæƒ¡æ–¹ç²å‹');
            return {
              ...prev,
              currentVotePhase: 'evil-wins',
              failedVotes: newFailedVotes
            };
          }
          return {
            ...prev,
            voteTally: newTally,
            currentVotePhase: 'team-selection',
            failedVotes: newFailedVotes,
            leader: players[newLeaderIndex].id,
            team: []
          };
        }
      }
      return { ...prev, voteTally: newTally };
    });
  };

  const startAvalonMissionVote = () => {
    setAvalonState(prev => ({ ...prev, currentVotePhase: 'mission-voting' }));
  };

  const recordAvalonMissionVote = (outcome) => {
    setAvalonState(prev => {
      const newVoteTally = { ...prev.missionVoteTally };
      if (outcome === 'success') {
        newVoteTally.success++;
      } else {
        newVoteTally.fail++;
      }
      if (newVoteTally.success + newVoteTally.fail === prev.team.length) {
        return {
          ...prev,
          missionVoteTally: newVoteTally,
          currentVotePhase: 'mission-result'
        };
      }
      return { ...prev, missionVoteTally: newVoteTally };
    });
  };

  const advanceAvalonQuest = () => {
    setAvalonState(prev => {
      const { missionVoteTally, currentQuest } = prev;
      const failVotesNeeded = (playerCount >= 7 && currentQuest === 4) ? 2 : 1;
      const isSuccess = missionVoteTally.fail < failVotesNeeded;
      
      const newResults = [...prev.questResults, isSuccess ? 'success' : 'fail'];
      const newLeaderIndex = (players.findIndex(p => p.id === prev.leader) + 1) % playerCount;
      const goodWins = newResults.filter(r => r === 'success').length === 3;
      const evilWins = newResults.filter(r => r === 'fail').length === 3;

      let nextState = {
        ...prev,
        questResults: newResults,
        team: [],
        missionVoteTally: { success: 0, fail: 0 },
        leader: players[newLeaderIndex].id,
        currentQuest: prev.currentQuest + 1
      };

      if (goodWins) {
        nextState.currentVotePhase = 'assassination';
      } else if (evilWins) {
        nextState.currentVotePhase = 'evil-wins';
        endGame('é‚ªæƒ¡æ–¹ç²å‹');
      } else {
        nextState.currentVotePhase = 'team-selection';
      }
      return nextState;
    });
  };

  const assassinatePlayer = (playerId) => {
    const targetPlayer = players.find(p => p.id === playerId);
    let outcomeMessage = '';
    let finalPhase = '';

    if (targetPlayer.role === 'merlin') {
      outcomeMessage = 'åˆºå®¢æˆåŠŸåˆºæ®ºæ¢…æ—ï¼Œé‚ªæƒ¡æ–¹ç²å‹ï¼';
      finalPhase = 'evil-wins';
      endGame('é‚ªæƒ¡æ–¹ç²å‹');
    } else {
      outcomeMessage = 'åˆºå®¢åˆºæ®ºå¤±æ•—ï¼Œæ­£ç¾©æ–¹ç²å‹ï¼';
      finalPhase = 'good-wins';
      endGame('æ­£ç¾©æ–¹ç²å‹');
    }

    showMessageWithTimeout(outcomeMessage);
    setAvalonState(prev => ({ ...prev, assassinationTarget: playerId, currentVotePhase: finalPhase }));
  };

  const showQuestTeamModal = (index) => {
    setAvalonState(prev => ({ ...prev, showQuestTeamModal: true, selectedQuestIndex: index }));
  };
  const hideQuestTeamModal = () => {
    setAvalonState(prev => ({ ...prev, showQuestTeamModal: false, selectedQuestIndex: null }));
  };


  // --- Who's the Spy Logic ---
  const startWhosTheSpyTurn = () => {
    setWhosTheSpyState(prev => ({ ...prev, turn: 0, phase: 'describing' }));
    setCurrentPage('whos-the-spy-gameplay');
  };

  const nextWhosTheSpyTurn = () => {
    setWhosTheSpyState(prev => {
      const alivePlayers = players.filter(p => p.alive);
      const nextTurn = prev.turn + 1;
      if (nextTurn >= alivePlayers.length) {
        return { ...prev, phase: 'voting' };
      }
      return { ...prev, turn: nextTurn };
    });
  };

  const recordWhosTheSpyDescription = (playerId, description) => {
    setWhosTheSpyState(prev => ({
      ...prev,
      descriptions: {
        ...prev.descriptions,
        [playerId]: description
      }
    }));
  };

  const processWhosTheSpyVote = (votes) => {
    const voteCounts = {};
    votes.forEach(playerId => {
      voteCounts[playerId] = (voteCounts[playerId] || 0) + 1;
    });

    const maxVotes = Math.max(...Object.values(voteCounts));
    const playersWithMaxVotes = Object.keys(voteCounts).filter(id => voteCounts[id] === maxVotes);

    if (playersWithMaxVotes.length > 1) {
      showMessageWithTimeout('æŠ•ç¥¨å¹³æ‰‹ï¼Œè«‹å†æ¬¡é€²è¡ŒæŠ•ç¥¨ï¼');
      return;
    }
    
    const eliminatedPlayerId = parseInt(playersWithMaxVotes[0]);
    const eliminatedPlayer = players.find(p => p.id === eliminatedPlayerId);
    
    const newPlayers = players.map(p =>
      p.id === eliminatedPlayerId ? { ...p, alive: false } : p
    );
    setPlayers(newPlayers);

    showMessageWithTimeout(`ç©å®¶ ${eliminatedPlayer.name} å·²è¢«æ·˜æ±°ï¼ä»–çš„èº«ä»½æ˜¯ï¼š${gameData.whosTheSpy.roles.find(r => r.code === eliminatedPlayer.role)?.name}`);
    
    checkWhosTheSpyWin(newPlayers);
  };

  const checkWhosTheSpyWin = (currentPlayers) => {
    const alivePlayers = currentPlayers.filter(p => p.alive);
    const aliveRoles = alivePlayers.map(p => p.role);
    const aliveSpies = aliveRoles.filter(role => role === 'spy').length;
    const aliveBlanks = aliveRoles.filter(role => role === 'blank').length;
    const totalAlive = alivePlayers.length;
    const initialPlayerCount = currentPlayers.length;
    
    let winner = null;
    let winnerMessage = '';

    const spyWinCondition = (initialPlayerCount === 4 && totalAlive <= 2) || (initialPlayerCount > 4 && totalAlive <= 3);

    if (spyWinCondition && aliveSpies > 0) {
        winner = 'è‡¥åº•';
        winnerMessage = 'æ­å–œè‡¥åº•æ–¹ç²å‹ï¼';
    } else if (aliveSpies === 0 && aliveBlanks > 0) {
        winner = 'ç™½æ¿';
        winnerMessage = 'ç™½æ¿æ–¹ç²å‹ï¼';
    } else if (aliveSpies === 0) {
        winner = 'å¹³æ°‘';
        winnerMessage = 'æ­å–œå¹³æ°‘æ–¹ç²å‹ï¼';
    }

    if (winner) {
        const result = `${winner} é™£ç‡Ÿç²å‹`;
        showMessageWithTimeout(winnerMessage);
        endGame(result);
    } else {
        setWhosTheSpyState(prev => ({ ...prev, round: prev.round + 1, turn: 0, descriptions: {}, phase: 'describing' }));
    }
  };


  // --- Werewolf Logic ---
  const startWerewolfGame = () => {
    setWerewolfState({
        day: 1,
        phase: 'night-intro',
        killedPlayerId: null,
        poisonedPlayerId: null,
        savedPlayerId: null,
        witchHasAntidote: true,
        witchHasPoison: true,
        werewolfTargetId: null,
        seerTargetId: null,
        seerResult: null,
        guardianTargetId: null,
        killedList: [],
        playersToVote: [],
        votedOutPlayerId: null
    });
    setCurrentPage('werewolf-gameplay');
  };

  const checkWerewolfWin = (currentPlayers) => {
    const alivePlayers = currentPlayers.filter(p => p.alive);
    
    const evilRoles = gameData.werewolf.roles.filter(r => r.side === 'evil').map(r => r.code);
    const godRoles = gameData.werewolf.roles.filter(r => r.side === 'good' && r.code !== 'civilian').map(r => r.code);

    const hadGodsInitially = players.some(p => godRoles.includes(p.role));
    const hadCiviliansInitially = players.some(p => p.role === 'civilian');

    const aliveWolves = alivePlayers.filter(p => evilRoles.includes(p.role)).length;
    const aliveGods = alivePlayers.filter(p => godRoles.includes(p.role)).length;
    const aliveCivilians = alivePlayers.filter(p => p.role === 'civilian').length;
    
    let winner = null;

    if (aliveWolves === 0) {
        winner = 'å¥½äººé™£ç‡Ÿç²å‹';
    } else if ((hadGodsInitially && aliveGods === 0) || (hadCiviliansInitially && aliveCivilians === 0)) {
        winner = 'ç‹¼äººé™£ç‡Ÿç²å‹';
    }
    
    if(winner) {
      showMessageWithTimeout(`${winner}ï¼`);
      endGame(winner);
      return true;
    }
    return false;
  };
  
  const endNight = () => {
    setWerewolfState(prev => {
        const { werewolfTargetId, savedPlayerId, poisonedPlayerId, guardianTargetId } = prev;
        
        const killedThisNight = [];
        if (werewolfTargetId && savedPlayerId !== werewolfTargetId && guardianTargetId !== werewolfTargetId) {
            killedThisNight.push(werewolfTargetId);
        }
        if (poisonedPlayerId) {
            killedThisNight.push(poisonedPlayerId);
        }
        const uniqueKilled = [...new Set(killedThisNight)];

        const nightMessage = uniqueKilled.length > 0 ? "æ˜¨æ™šä¸æ˜¯ä¸€å€‹å¹³å®‰å¤œ..." : "å¤©äº®äº†ï¼Œæ˜¨æ™šæ˜¯å€‹å¹³å®‰å¤œã€‚";
        
        const newPlayers = players.map(p => 
            uniqueKilled.includes(p.id) ? { ...p, alive: false } : p
        );
        
        setPlayers(newPlayers);
        showMessageWithTimeout(nightMessage);

        if (checkWerewolfWin(newPlayers)) {
          return { ...prev, phase: 'end' };
        }
        
        return {
            ...prev,
            day: prev.day + 1,
            phase: 'day-announcement',
            killedList: uniqueKilled,
            werewolfTargetId: null,
            poisonedPlayerId: null,
            savedPlayerId: null,
            seerResult: null,
            guardianTargetId: null
        };
    });
  };

  const handleWerewolfAction = (targetId, role) => {
    const alivePlayers = players.filter(p => p.alive);
    switch (role) {
        case 'werewolf':
            setWerewolfState(prev => ({ ...prev, werewolfTargetId: targetId, phase: 'night-seer-intro' }));
            break;
        case 'seer':
            const targetRole = players.find(p => p.id === targetId)?.role;
            const isWolf = ['werewolf', 'wolf_king'].includes(targetRole);
            const resultMessage = isWolf ? `æŸ¥é©—å°è±¡ ${players.find(p => p.id === targetId)?.name} æ˜¯ç‹¼äººã€‚` : `æŸ¥é©—å°è±¡ ${players.find(p => p.id === targetId)?.name} æ˜¯å¥½äººã€‚`;
            setWerewolfState(prev => ({ ...prev, seerTargetId: targetId, seerResult: resultMessage }));
            break;
        case 'witch-antidote':
            setWerewolfState(prev => ({ ...prev, savedPlayerId: prev.werewolfTargetId, witchHasAntidote: false, phase: 'night-end' }));
            break;
        case 'witch-poison':
            setWerewolfState(prev => ({ ...prev, poisonedPlayerId: targetId, witchHasPoison: false, phase: 'night-end' }));
            break;
        default:
            break;
    }
  };
  
  const startDayDiscussion = () => {
      setWerewolfState(prev => ({...prev, phase: 'day-discussion'}));
  };

  const startDayVoting = () => {
    const alivePlayers = players.filter(p => p.alive);
    setWerewolfState(prev => ({ ...prev, phase: 'day-voting', playersToVote: alivePlayers.map(p => p.id) }));
  };

  const processWerewolfVote = (votes) => {
    const voteCounts = {};
    votes.forEach(playerId => {
      voteCounts[playerId] = (voteCounts[playerId] || 0) + 1;
    });

    const maxVotes = Math.max(...Object.values(voteCounts));
    const playersWithMaxVotes = Object.keys(voteCounts).filter(id => voteCounts[id] === maxVotes);

    if (playersWithMaxVotes.length > 1) {
      showMessageWithTimeout('æŠ•ç¥¨å¹³æ‰‹ï¼Œè«‹å†æ¬¡é€²è¡ŒæŠ•ç¥¨ï¼');
      return;
    }
    
    const eliminatedPlayerId = parseInt(playersWithMaxVotes[0]);
    const eliminatedPlayer = players.find(p => p.id === eliminatedPlayerId);
    
    let hunterShotId = null;
    let wolfKingShotId = null;
    let idiotSaved = false;

    if (eliminatedPlayer?.role === 'idiot') {
        idiotSaved = window.confirm(`ç©å®¶ ${eliminatedPlayer.name} (ç™½ç™¡) è¢«æŠ•ç¥¨å‡ºå±€äº†ï¼Œæ˜¯å¦ç¿»ç‰Œå…æ­»ï¼Ÿ`);
        if (idiotSaved) {
            showMessageWithTimeout('ç™½ç™¡æˆåŠŸç¿»ç‰Œï¼Œå…æ–¼å‡ºå±€ï¼');
            setWerewolfState(prev => ({ ...prev, phase: 'day-end', votedOutPlayerId: null }));
            return;
        }
    }
    
    if (eliminatedPlayer?.role === 'hunter' || eliminatedPlayer?.role === 'wolf_king') {
        const targetName = prompt(`ç©å®¶ ${eliminatedPlayer.name} (çµäºº/ç‹¼ç‹) æ±ºå®šé–‹æ§ï¼Œè«‹é¸æ“‡è¦å¸¶èµ°çš„ç©å®¶åç¨±ï¼š`);
        const targetPlayer = players.find(p => p.name === targetName && p.alive);
        if (targetPlayer && targetPlayer.id !== eliminatedPlayerId) {
            if (eliminatedPlayer.role === 'hunter') hunterShotId = targetPlayer.id;
            else wolfKingShotId = targetPlayer.id;
        }
    }
    
    const newPlayers = players.map(p => {
        let newP = { ...p };
        if (p.id === eliminatedPlayerId || p.id === hunterShotId || p.id === wolfKingShotId) {
            newP.alive = false;
        }
        return newP;
    });

    setPlayers(newPlayers);
    
    showMessageWithTimeout(`ç©å®¶ ${eliminatedPlayer.name} è¢«æŠ•ç¥¨å‡ºå±€äº†ã€‚`);
    if (hunterShotId) showMessageWithTimeout(`çµäººé–‹æ§ï¼Œç©å®¶ ${players.find(p => p.id === hunterShotId)?.name} ä¹Ÿå‡ºå±€äº†ã€‚`);
    if (wolfKingShotId) showMessageWithTimeout(`ç‹¼ç‹é–‹æ§ï¼Œç©å®¶ ${players.find(p => p.id === wolfKingShotId)?.name} ä¹Ÿå‡ºå±€äº†ã€‚`);

    if (checkWerewolfWin(newPlayers)) return;

    setWerewolfState(prev => ({ ...prev, phase: 'day-end', votedOutPlayerId: eliminatedPlayerId, killedList: [] }));
  };

  // --- General UI Components ---
  const Home = () => (
    <div className="text-center p-4">
      <h2 className="text-3xl font-bold text-gray-800 mb-6">è«‹é¸æ“‡éŠæˆ²</h2>
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        {Object.keys(gameData).map(mode => (
          <button
            key={mode}
            onClick={() => setupGame(mode)}
            className="flex flex-col items-center p-6 bg-indigo-500 text-white rounded-3xl shadow-lg transition-transform hover:scale-105"
          >
            <span className="mb-2 text-5xl">{gameData[mode].icon}</span>
            <span className="text-xl font-bold">{gameData[mode].name}</span>
          </button>
        ))}
      </div>
      <div className="mt-8">
        <button
          onClick={() => setCurrentPage('history')}
          className="w-full py-3 px-6 bg-gray-200 text-gray-800 rounded-full font-bold shadow-md hover:bg-gray-300 transition"
        >
          <span className="inline-block mr-2">ğŸ“š</span>
          éŠæˆ²ç´€éŒ„
        </button>
      </div>
    </div>
  );

  const Setup = () => (
    <div className="p-4 space-y-6">
      <div className="flex items-center justify-between">
        <button onClick={resetGame} className="text-gray-600 hover:text-gray-800 text-3xl">â¬…ï¸</button>
        <h2 className="text-2xl font-bold text-gray-800">
          <span className="mr-2">{gameData[gameMode].icon}</span>
          {gameData[gameMode].name} è¨­å®š
        </h2>
        <div className="w-8"></div>
      </div>
      {gameMode === 'whosTheSpy' && (
        <button
          onClick={fetchNewWords}
          disabled={isFetchingWords}
          className="w-full py-3 mt-4 bg-purple-500 text-white rounded-xl shadow-lg transition-all hover:bg-purple-600 disabled:bg-gray-400 disabled:cursor-not-allowed"
        >
          {isFetchingWords ? (
            <div className="flex justify-center items-center">
              <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
              ç”Ÿæˆä¸­...
            </div>
          ) : (
            <>
              <span className="inline-block mr-2">âš¡</span>
              å–å¾—æ–°è©èª
            </>
          )}
        </button>
      )}
      <div>
        <label className="block text-lg font-semibold mb-2 text-gray-700">é¸æ“‡ç©å®¶äººæ•¸</label>
        <select
          value={playerCount}
          onChange={(e) => {
            const newCount = parseInt(e.target.value);
            setPlayerCount(newCount);
            updateRoleCounts(gameMode, newCount);
          }}
          className="w-full p-3 rounded-xl border border-gray-300"
        >
          {Object.keys(gameData[gameMode].playerConfigs).map(num => (
            <option key={num} value={num}>{num} äºº</option>
          ))}
        </select>
      </div>
      <div>
        <label className="block text-lg font-semibold mb-2 text-gray-700">è‡ªå®šç¾©è§’è‰²</label>
        <div className="space-y-3">
          {gameData[gameMode].roles.map(role => (
            <div key={role.code} className="flex items-center justify-between p-3 bg-gray-100 rounded-xl">
              <div className="flex items-center">
                <span className="text-xl mr-2">{role.icon}</span>
                <span className="font-medium text-gray-700">{role.name}</span>
              </div>
              <input
                type="number"
                min="0"
                value={roleCounts[role.code] || 0}
                onChange={(e) => setRoleCounts(prev => ({ ...prev, [role.code]: parseInt(e.target.value) || 0 }))}
                className="w-16 text-center border rounded-lg"
              />
            </div>
          ))}
          <div className="flex items-center justify-between font-bold text-gray-800 mt-4">
            <span>ç¸½äººæ•¸:</span>
            <span>{Object.values(roleCounts).reduce((sum, count) => sum + count, 0)} / {playerCount}</span>
          </div>
        </div>
      </div>
      <button
        onClick={handleStartGame}
        className="w-full py-3 mt-6 bg-green-500 text-white rounded-xl shadow-lg transition-all hover:bg-green-600"
      >
        é–‹å§‹éŠæˆ²
      </button>
    </div>
  );

  const RoleReveal = () => {
    const player = players[currentPlayerIndex];

    if (!player) return null;

    return (
      <div className="flex flex-col items-center justify-center p-4">
        <h2 className="text-2xl font-bold text-gray-800 mb-4">è«‹å‚³çµ¦ä¸‹ä¸€ä½ç©å®¶</h2>
        <div className="bg-white p-6 rounded-2xl shadow-xl w-full max-w-sm text-center">
          <p className="text-lg text-gray-600 mb-2">è¼ªåˆ°</p>
          <p className="text-4xl font-bold text-indigo-600">{player.name}</p>
          <div className="h-64 mt-4 relative">
            <div
              className={`relative w-full h-full transform-gpu transition-transform duration-500`}
              style={{ transformStyle: 'preserve-3d', transform: isCardFlipped ? 'rotateY(180deg)' : '' }}
            >
              {/* Card Front (Face down) */}
              <div
                onClick={() => setIsCardFlipped(true)}
                className="absolute inset-0 bg-indigo-500 rounded-2xl flex items-center justify-center p-4 cursor-pointer"
                style={{ backfaceVisibility: 'hidden' }}>
                <span className="text-white text-3xl font-bold">é»æ“ŠæŸ¥çœ‹èº«ä»½</span>
              </div>
              {/* Card Back (Face up) */}
              <div
                className="absolute inset-0 bg-white rounded-2xl flex flex-col items-center justify-center p-4"
                style={{ backfaceVisibility: 'hidden', transform: 'rotateY(180deg)' }}>
                <div className="text-4xl text-indigo-500">
                  {gameData[gameMode].roles.find(r => r.code === player.role)?.icon}
                </div>
                <h3 className="text-xl font-bold mt-2 text-gray-800">{gameData[gameMode].roles.find(r => r.code === player.role)?.name}</h3>
                {gameMode === 'whosTheSpy' && (
                  <p className="text-md mt-2 text-gray-600">
                    è©èª: <span className="font-semibold">{player.word === null ? 'ç„¡' : player.word}</span>
                  </p>
                )}
                <div className="mt-4 space-y-2">
                  <p className="text-xs text-gray-500">
                    {gameData[gameMode].roles.find(r => r.code === player.role)?.description}
                  </p>
                  {/* Avalon additional information */}
                  {gameMode === 'avalon' && (
                    <div className="text-xs text-center text-gray-500">
                      {/* Merlin */}
                      {player.role === 'merlin' && (
                        <p>é‚ªæƒ¡æ–¹æˆå“¡ï¼š<br />
                          {players.filter(p => gameData.avalon.roles.find(r => r.code === p.role)?.side === 'evil' && p.role !== 'mordred').map(p => p.name).join('ã€')}
                        </p>
                      )}
                      {/* Percival */}
                      {player.role === 'percival' && (
                        <p>æ¢…æ—æˆ–è«ç”˜å¨œï¼š<br />
                          {players.filter(p => p.role === 'merlin' || p.role === 'morgana').map(p => p.name).join('ã€')}
                        </p>
                      )}
                      {/* Evil */}
                      {getPlayerRoleInfo(player.role)?.side === 'evil' && player.role !== 'oberon' && (
                        <p>é‚ªæƒ¡åŒä¼´ï¼š<br />
                          {players.filter(p => p.id !== player.id && getPlayerRoleInfo(p.role)?.side === 'evil' && p.role !== 'oberon').map(p => p.name).join('ã€')}
                        </p>
                      )}
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>
        </div>
        <button
          onClick={nextPlayerReveal}
          className={`w-full max-w-sm py-3 mt-6 bg-green-500 text-white rounded-xl shadow-lg transition-all hover:bg-green-600 ${!isCardFlipped ? 'opacity-50 cursor-not-allowed' : ''}`}
          disabled={!isCardFlipped}
        >
          {currentPlayerIndex === players.length - 1 ? 'é–‹å§‹éŠæˆ²' : `ä¸‹ä¸€ä½ç©å®¶ (${currentPlayerIndex + 1}/${players.length})`}
        </button>
      </div>
    );
  };

  const WhosTheSpyGameplay = () => {
    const alivePlayers = players.filter(p => p.alive);
    const currentPlayer = alivePlayers[whosTheSpyState.turn];

    const handleVote = () => {
      const radios = document.querySelectorAll('input[name="vote"]:checked');
      if (radios.length === 0) {
        showMessageWithTimeout('è«‹é¸æ“‡ä¸€ä½ç©å®¶æŠ•ç¥¨ï¼');
        return;
      }
      processWhosTheSpyVote([parseInt(radios[0].value)]);
    };

    return (
      <div className="p-4 space-y-6">
        <h2 className="text-2xl font-bold text-gray-800 mb-4">
          <span className="inline-block mr-2">ğŸ‘»</span>
          èª°æ˜¯è‡¥åº• - ç¬¬ {whosTheSpyState.round} å›åˆ
        </h2>

        <div className="bg-white p-4 rounded-xl shadow-md">
          <h3 className="text-lg font-bold mb-2">å­˜æ´»ç©å®¶</h3>
          <div className="flex flex-wrap gap-2">
            {alivePlayers.map(p => (
              <span key={p.id} className="bg-gray-200 text-gray-800 text-sm font-semibold px-2 py-1 rounded-full">
                {p.name}
              </span>
            ))}
          </div>
        </div>

        {whosTheSpyState.phase === 'describing' && (
          <div className="bg-white p-4 rounded-xl shadow-md text-center">
            <h3 className="text-lg font-bold mb-2">ç™¼è¨€æ™‚é–“</h3>
            <p className="text-gray-600 mb-4">è¼ªåˆ° <span className="text-indigo-600 font-bold">{currentPlayer?.name}</span> æè¿°ã€‚</p>
            <button onClick={nextWhosTheSpyTurn} className="w-full py-3 bg-green-500 text-white rounded-xl shadow-lg hover:bg-green-600">
              {whosTheSpyState.turn === alivePlayers.length - 1 ? 'ç™¼è¨€çµæŸï¼Œé–‹å§‹æŠ•ç¥¨' : 'ä¸‹ä¸€ä½ç©å®¶'}
            </button>
          </div>
        )}

        {whosTheSpyState.phase === 'voting' && (
          <div className="bg-white p-4 rounded-xl shadow-md">
            <h3 className="text-lg font-bold mb-2">æŠ•ç¥¨æ·˜æ±°</h3>
            <p className="text-gray-600 mb-4">è«‹æ‰€æœ‰ç©å®¶æŠ•ç¥¨é¸å‡ºä½ æ‡·ç–‘çš„å°è±¡ã€‚</p>
            <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
              {alivePlayers.map(player => (
                <div key={player.id} className="flex items-center space-x-2 p-2 bg-gray-100 rounded-lg">
                  <input type="radio" id={`vote-${player.id}`} name="vote" value={player.id} className="h-4 w-4 text-blue-600 focus:ring-blue-500" />
                  <label htmlFor={`vote-${player.id}`} className="text-lg font-medium text-gray-800">{player.name}</label>
                </div>
              ))}
            </div>
            <button onClick={handleVote} className="w-full py-3 mt-4 bg-red-500 text-white rounded-xl shadow-lg hover:bg-red-600">
              ç¢ºèªæŠ•ç¥¨
            </button>
          </div>
        )}

        <button onClick={resetGame} className="w-full py-3 bg-gray-200 text-gray-800 rounded-xl shadow-md transition-all hover:bg-gray-300 mt-2">
          è¿”å›é¦–é 
        </button>
      </div>
    );
  };

  const AvalonGameplay = () => {
    const isGoodWins = avalonState.questResults.filter(r => r === 'success').length === 3;
    const isEvilWins = avalonState.questResults.filter(r => r === 'fail').length === 3 || avalonState.failedVotes >= 5;
    const questSize = playerCount > 0 ? gameData.avalon.questSizes[playerCount][avalonState.currentQuest - 1] : 0;
    const currentLeader = players.find(p => p.id === avalonState.leader);

    const getOutcomeColor = (outcome) => {
      if (outcome === 'success') return 'bg-blue-500';
      if (outcome === 'fail') return 'bg-red-500';
      return 'bg-gray-400';
    };

    return (
      <div className="p-4 space-y-6">
        <div className="flex items-center justify-between mb-4">
          <button onClick={resetGame} className="text-gray-600 hover:text-gray-800 text-3xl">â¬…ï¸</button>
          <h2 className="text-2xl font-bold text-gray-800">é˜¿ç“¦éš†</h2>
          <div className="w-8"></div>
        </div>

        {/* Scoreboard */}
        <div className="bg-white p-4 rounded-xl shadow-md">
          <h3 className="text-lg font-bold mb-2">ä»»å‹™é€²åº¦</h3>
          <div className="flex justify-around items-center space-x-2">
            {[0, 1, 2, 3, 4].map(qIndex => (
              <button
                key={qIndex}
                onClick={() => avalonState.questTeams && avalonState.questTeams[qIndex] && showQuestTeamModal(qIndex)}
                className={`relative w-12 h-12 rounded-full flex flex-col items-center justify-center text-white font-bold transition-colors ${getOutcomeColor(avalonState.questResults[qIndex])}`}
              >
                {avalonState.questResults[qIndex] ? (
                  <>
                    <span className="text-xl">{gameData.avalon.questSizes[playerCount]?.[qIndex]}</span>
                    <span className="text-xs absolute bottom-1">{avalonState.questResults[qIndex] === 'success' ? 'æˆåŠŸ' : 'å¤±æ•—'}</span>
                  </>
                ) : (
                  <span className="text-xl">{gameData.avalon.questSizes[playerCount]?.[qIndex]}</span>
                )}
              </button>
            ))}
          </div>
          <p className="mt-4 text-center font-semibold text-gray-700">åœ˜éšŠæŠ•ç¥¨å¤±æ•—: {avalonState.failedVotes} / 5</p>
        </div>
        
        {/* Quest Team Modal */}
        {avalonState.showQuestTeamModal && (
          <div className="fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center z-50 p-4">
            <div className="bg-white p-6 rounded-2xl shadow-xl w-full max-w-sm text-center">
              <h3 className="text-2xl font-bold mb-4">
                ç¬¬ {avalonState.selectedQuestIndex + 1} æ¬¡ä»»å‹™åœ˜éšŠ
              </h3>
              <ul className="space-y-2 text-lg">
                {avalonState.questTeams[avalonState.selectedQuestIndex].members.map(playerId => (
                  <li key={playerId} className="p-2 bg-gray-100 rounded-lg">{players.find(p => p.id === playerId)?.name}</li>
                ))}
              </ul>
              <button
                onClick={hideQuestTeamModal}
                className="w-full mt-6 py-3 bg-indigo-500 text-white rounded-xl hover:bg-indigo-600"
              >
                é—œé–‰
              </button>
            </div>
          </div>
        )}

        {/* Game State */}
        {avalonState.currentVotePhase === 'assassination' && (
          <div className="bg-white p-4 rounded-xl shadow-md">
            <h3 className="text-lg font-bold mb-2 text-red-600 flex items-center">
              <span className="mr-2">ğŸ¯</span>
              åˆºå®¢è«‹é¸æ“‡æ¢…æ—
            </h3>
            <div className="grid grid-cols-3 gap-4">
              {players.filter(p => getPlayerRoleInfo(p.role)?.side === 'good').map(p => (
                <button
                  key={p.id}
                  onClick={() => assassinatePlayer(p.id)}
                  className={`p-2 rounded-lg text-center cursor-pointer border-2 transition-all hover:bg-red-200 ${avalonState.assassinationTarget === p.id ? 'bg-red-400 text-white border-red-500' : 'bg-gray-100 border-gray-300'}`}
                >
                  <span className="text-3xl">ğŸ‘¤</span>
                  <p className="font-semibold text-sm mt-1">{p.name}</p>
                </button>
              ))}
            </div>
          </div>
        )}

        {!(isGoodWins || isEvilWins) && (
          <>
            {/* Team Selection */}
            {avalonState.currentVotePhase === 'team-selection' && (
              <div className="bg-white p-4 rounded-xl shadow-md text-center">
                <p className="text-xl font-bold mb-2">
                  <span className="text-yellow-600 mr-2">é ˜è¢–:</span> {currentLeader?.name}
                </p>
                <p className="text-lg font-bold text-gray-700">
                  <span className="text-blue-600 mr-2">ä»»å‹™äººæ•¸:</span> {avalonState.team.length} / {questSize}
                </p>
                <div className="grid grid-cols-3 gap-4 my-4">
                  {players.map(p => {
                     const isLeader = avalonState.leader === p.id;
                     const onTeam = avalonState.team.includes(p.id);
                     let playerClass = 'bg-gray-100 border-gray-300';
                     if (onTeam) playerClass = 'bg-blue-400 text-white border-blue-500';
                     else if (isLeader) playerClass = 'bg-yellow-400 border-yellow-500';

                    return (
                        <button
                          key={p.id}
                          onClick={() => togglePlayerSelection(p.id)}
                          className={`p-2 rounded-lg text-center cursor-pointer border-2 transition-all ${playerClass}`}
                        >
                          {isLeader && <span className="text-xl">ğŸ‘‘</span>}
                          <span className="text-3xl">ğŸ‘¤</span>
                          <p className="font-semibold text-sm mt-1">{p.name}</p>
                        </button>
                    );
                  })}
                </div>
                <button
                  onClick={startAvalonTeamVote}
                  disabled={avalonState.team.length !== questSize}
                  className={`w-full py-3 mt-4 rounded-xl shadow-lg transition-all ${avalonState.team.length !== questSize ? 'bg-gray-400 cursor-not-allowed' : 'bg-green-500 text-white hover:bg-green-600'}`}
                >
                  ç™¼èµ·æŠ•ç¥¨
                </button>
              </div>
            )}
            
            {/* Team Voting */}
            {avalonState.currentVotePhase === 'team-voting' && (
              <div className="bg-white p-4 rounded-xl shadow-md text-center">
                <h3 className="text-lg font-bold mb-2">åœ˜éšŠæŠ•ç¥¨</h3>
                <p className="text-gray-500 text-sm mb-4">
                  å·²æŠ•ç¥¨äººæ•¸: {(avalonState.voteTally?.approve || 0) + (avalonState.voteTally?.reject || 0)} / {playerCount}
                </p>
                <div className="flex justify-center space-x-4">
                  <button onClick={() => recordAvalonTeamVote('approve')} className="p-4 rounded-xl bg-green-500 text-white hover:bg-green-600 transition-colors">
                    <span className="text-3xl">âœ…</span>
                    <p className="text-sm">é€šé</p>
                  </button>
                  <button onClick={() => recordAvalonTeamVote('reject')} className="p-4 rounded-xl bg-red-500 text-white hover:bg-red-600 transition-colors">
                    <span className="text-3xl">âŒ</span>
                    <p className="text-sm">ä¸é€šé</p>
                  </button>
                </div>
              </div>
            )}
            
            {/* Mission Voting */}
            {avalonState.currentVotePhase === 'mission-voting' && (
                <div className="bg-white p-4 rounded-xl shadow-md text-center">
                    <h3 className="text-lg font-bold mb-2">ä»»å‹™æŠ•ç¥¨</h3>
                    <p className="text-gray-500 text-sm mb-4">
                      è«‹åƒèˆ‡ä»»å‹™çš„ç©å®¶é¸æ“‡ã€ŒæˆåŠŸã€æˆ–ã€Œå¤±æ•—ã€ã€‚
                    </p>
                    <p className="font-bold text-gray-700">
                        å·²æŠ•ç¥¨: {avalonState.missionVoteTally.success + avalonState.missionVoteTally.fail} / {avalonState.team.length}
                    </p>
                    <div className="flex justify-center space-x-4 mt-4">
                        <button onClick={() => recordAvalonMissionVote('success')} className="p-4 rounded-xl bg-blue-500 text-white hover:bg-blue-600 transition-colors">
                            <span className="text-3xl">ğŸ˜Š</span>
                            <p className="text-sm">æˆåŠŸ</p>
                        </button>
                        <button onClick={() => recordAvalonMissionVote('fail')} className="p-4 rounded-xl bg-red-500 text-white hover:bg-red-600 transition-colors">
                            <span className="text-3xl">ğŸ˜ </span>
                            <p className="text-sm">å¤±æ•—</p>
                        </button>
                    </div>
                </div>
            )}

            {/* Mission Result */}
            {avalonState.currentVotePhase === 'mission-result' && (
                <div className="bg-white p-4 rounded-xl shadow-md text-center">
                    <h3 className="text-lg font-bold mb-2">ä»»å‹™çµæœ</h3>
                    <div className="flex justify-center space-x-4 mb-4">
                        <div className="flex items-center text-blue-600 font-bold">
                            <span className="mr-1">âœ…</span>æˆåŠŸ: {avalonState.missionVoteTally.success}
                        </div>
                        <div className="flex items-center text-red-600 font-bold">
                            <span className="mr-1">âŒ</span>å¤±æ•—: {avalonState.missionVoteTally.fail}
                        </div>
                    </div>
                    <button onClick={advanceAvalonQuest} className="w-full py-3 mt-4 bg-green-500 text-white rounded-xl shadow-lg hover:bg-green-600">
                      é€²å…¥ä¸‹ä¸€å›åˆ
                    </button>
                </div>
            )}
          </>
        )}
      </div>
    );
  };

  const WerewolfGameplay = () => {
    const alivePlayers = players.filter(p => p.alive);
    const hasSeer = players.some(p => p.role === 'seer' && p.alive);
    const hasWitch = players.some(p => p.role === 'witch' && p.alive);
    const seer = players.find(p => p.role === 'seer' && p.alive);

    const handleVote = () => {
      const radios = document.querySelectorAll('input[name="vote"]:checked');
      if (radios.length === 0) {
        showMessageWithTimeout('è«‹é¸æ“‡ä¸€ä½ç©å®¶æŠ•ç¥¨ï¼');
        return;
      }
      processWerewolfVote([parseInt(radios[0].value)]);
    };
    
    const IntroScreen = ({ title, description, nextPhase }) => (
      <div className="bg-white p-4 rounded-xl shadow-md text-center">
        <h3 className="text-lg font-bold mb-2">{title}</h3>
        <p className="text-gray-600">{description}</p>
        <button onClick={() => setWerewolfState(prev => ({ ...prev, phase: nextPhase }))} className="w-full py-3 mt-4 bg-indigo-500 text-white rounded-xl shadow-lg hover:bg-indigo-600">
            ç¹¼çºŒ
        </button>
      </div>
    );

    return (
        <div className="p-4 space-y-6">
            <h2 className="text-2xl font-bold text-gray-800">
                <span className="inline-block mr-2">ğŸª“</span>
                ç‹¼äººæ®º - ç¬¬ {werewolfState.day} {werewolfState.phase.startsWith('day') ? 'å¤©' : 'å¤œ'}
            </h2>
            
            <div className="bg-gray-800 text-white p-4 rounded-xl shadow-md">
              <h3 className="text-lg font-bold mb-2 flex items-center"><span className="mr-2">ğŸ’€</span>æ­»äº¡åå–®</h3>
              <div className="flex flex-wrap gap-2">
                {players.filter(p => !p.alive).length > 0 ? (
                  players.filter(p => !p.alive).map(p => (
                    <span key={p.id} className="bg-red-500 text-white text-sm font-semibold px-2 py-1 rounded-full line-through">
                      {p.name} ({getPlayerRoleInfo(p.role)?.name})
                    </span>
                  ))
                ) : (
                  <p className="text-gray-400 text-sm">ç›®å‰å°šç„¡ç©å®¶å‡ºå±€ã€‚</p>
                )}
              </div>
            </div>

            {werewolfState.phase === 'night-intro' && <IntroScreen title="å¤œæ™šé–‹å§‹" description="å¤©é»‘è«‹é–‰çœ¼ã€‚" nextPhase="night-werewolves" />}
            
            {werewolfState.phase === 'night-werewolves' && (
                <div className="bg-white p-4 rounded-xl shadow-md text-center">
                    <h3 className="text-lg font-bold mb-2">ç‹¼äººè¡Œå‹•</h3>
                    <p className="text-gray-600">ç‹¼äººè«‹çœçœ¼ï¼Œä¸¦é¸æ“‡è¦æ®ºå®³çš„ç©å®¶ã€‚</p>
                    <div className="grid grid-cols-2 md:grid-cols-3 gap-4 mt-4">
                        {alivePlayers.filter(p => getPlayerRoleInfo(p.role)?.side !== 'evil').map(p => (
                            <button key={p.id} onClick={() => handleWerewolfAction(p.id, 'werewolf')} className="p-2 rounded-lg bg-gray-100 border border-gray-300 text-gray-800 hover:bg-red-200">
                                <span className="text-3xl">ğŸ‘¤</span>
                                <p className="font-semibold text-sm mt-1">{p.name}</p>
                            </button>
                        ))}
                    </div>
                </div>
            )}

            {werewolfState.phase === 'night-seer-intro' && <IntroScreen title="ç‹¼äººè«‹é–‰çœ¼" description="é è¨€å®¶è«‹çœçœ¼ã€‚" nextPhase="night-seer" />}
            
            {werewolfState.phase === 'night-seer' && hasSeer && (
              <div className="bg-white p-4 rounded-xl shadow-md text-center">
                <h3 className="text-lg font-bold mb-2">é è¨€å®¶è¡Œå‹•</h3>
                <p className="text-gray-600">è«‹é¸æ“‡è¦æŸ¥é©—çš„ç©å®¶ã€‚</p>
                {werewolfState.seerResult ? (
                    <>
                        <div className="p-2 mt-4 bg-blue-100 rounded-lg text-blue-700 font-semibold">
                            {werewolfState.seerResult}
                        </div>
                        <button
                            onClick={() => setWerewolfState(prev => ({ ...prev, phase: 'night-witch-intro' }))}
                            className="w-full py-3 mt-4 bg-indigo-500 text-white rounded-xl shadow-lg hover:bg-indigo-600"
                        >
                            ç¹¼çºŒ
                        </button>
                    </>
                ) : (
                    <div className="grid grid-cols-2 md:grid-cols-3 gap-4 mt-4">
                        {alivePlayers.filter(p => p.id !== seer?.id).map(p => (
                            <button key={p.id} onClick={() => handleWerewolfAction(p.id, 'seer')} className="p-2 rounded-lg bg-gray-100 border border-gray-300 text-gray-800 hover:bg-blue-200">
                                <span className="text-3xl">ğŸ‘¤</span>
                                <p className="font-semibold text-sm mt-1">{p.name}</p>
                            </button>
                        ))}
                    </div>
                )}
              </div>
            )}
            
            {werewolfState.phase === 'night-seer' && !hasSeer && (
              <IntroScreen title="é è¨€å®¶å·²å‡ºå±€" description="ç›´æ¥é€²å…¥ä¸‹ä¸€éšæ®µã€‚" nextPhase="night-witch-intro" />
            )}

            {werewolfState.phase === 'night-witch-intro' && <IntroScreen title="é è¨€å®¶è«‹é–‰çœ¼" description="å¥³å·«è«‹çœçœ¼ã€‚" nextPhase="night-witch" />}

            {werewolfState.phase === 'night-witch' && hasWitch && (
              <div className="bg-white p-4 rounded-xl shadow-md text-center">
                <h3 className="text-lg font-bold mb-2">å¥³å·«è¡Œå‹•</h3>
                <p className="text-gray-600">ä»Šæ™š <span className="text-red-600 font-bold">{players.find(p => p.id === werewolfState.werewolfTargetId)?.name}</span> è¢«æ®ºå®³äº†ã€‚</p>
                <div className="flex flex-col space-y-4 mt-4">
                  {werewolfState.witchHasAntidote && (
                    <button onClick={() => handleWerewolfAction(werewolfState.werewolfTargetId, 'witch-antidote')} className="w-full py-3 bg-blue-500 text-white rounded-xl shadow-lg hover:bg-blue-600">
                      <span className="inline-block mr-2">ğŸ›¡ï¸</span>
                      ä½¿ç”¨è§£è—¥
                    </button>
                  )}
                  {werewolfState.witchHasPoison && (
                    <div className="w-full">
                      <p className="text-gray-500 mb-2">æˆ–é¸æ“‡æ¯’æ®ºå°è±¡:</p>
                      <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
                        {alivePlayers.filter(p => p.id !== werewolfState.werewolfTargetId).map(p => (
                          <button key={p.id} onClick={() => handleWerewolfAction(p.id, 'witch-poison')} className="p-2 rounded-lg bg-gray-100 border border-gray-300 text-gray-800 hover:bg-purple-200">
                            <span className="inline-block mr-2 text-purple-600">ğŸ’€</span>
                            {p.name}
                          </button>
                        ))}
                      </div>
                    </div>
                  )}
                  <button onClick={() => setWerewolfState(prev => ({ ...prev, phase: 'night-end' }))} className="w-full py-3 bg-gray-200 text-gray-800 rounded-xl shadow-md hover:bg-gray-300">
                    ä¸ä½¿ç”¨è—¥åŠ‘
                  </button>
                </div>
              </div>
            )}
            
            {werewolfState.phase === 'night-witch' && !hasWitch && (
              <IntroScreen title="å¥³å·«å·²å‡ºå±€" description="ç›´æ¥é€²å…¥ä¸‹ä¸€éšæ®µã€‚" nextPhase="night-end" />
            )}
            
            {werewolfState.phase === 'night-end' && (
                <div className="bg-white p-4 rounded-xl shadow-md text-center">
                    <h3 className="text-lg font-bold mb-2">å¤œæ™šçµæŸ</h3>
                    <p className="text-gray-600">å¤©äº®äº†ï¼Œè«‹ä¸»æŒäººé»æ“ŠæŒ‰éˆ•çµæŸå¤œæ™šã€‚</p>
                    <button onClick={endNight} className="w-full py-3 mt-4 bg-green-500 text-white rounded-xl shadow-lg hover:bg-green-600">
                        å¤©äº®äº†ï¼Œæ­æ›‰çµæœ
                    </button>
                </div>
            )}

            {werewolfState.phase === 'day-announcement' && (
                <div className="bg-white p-4 rounded-xl shadow-md text-center">
                    <h3 className="text-lg font-bold mb-2">ç™½å¤©å®£å‘Š</h3>
                    {werewolfState.killedList.length > 0 ? (
                        <>
                            <p className="text-gray-600 font-bold">æ˜¨æ™šå‡ºå±€çš„ç©å®¶æœ‰ï¼š</p>
                            <ul className="mt-2 space-y-1">
                                {werewolfState.killedList.map(playerId => (
                                    <li key={playerId} className="text-red-600 text-lg font-bold">
                                        {players.find(p => p.id === playerId)?.name}
                                    </li>
                                ))}
                            </ul>
                            <button onClick={startDayDiscussion} className="w-full py-3 mt-4 bg-indigo-500 text-white rounded-xl shadow-lg hover:bg-indigo-600">
                                é–‹å§‹ç™½å¤©è¨è«–
                            </button>
                        </>
                    ) : (
                        <>
                            <p className="text-gray-600 font-bold">æ˜¨æ™šæ˜¯å€‹å¹³å®‰å¤œï¼Œæ²’æœ‰äººå‡ºå±€ã€‚</p>
                            <button onClick={startDayDiscussion} className="w-full py-3 mt-4 bg-indigo-500 text-white rounded-xl shadow-lg hover:bg-indigo-600">
                                é–‹å§‹ç™½å¤©è¨è«–
                            </button>
                        </>
                    )}
                </div>
            )}

            {werewolfState.phase === 'day-discussion' && (
              <div className="bg-white p-4 rounded-xl shadow-md text-center">
                <h3 className="text-lg font-bold mb-2">ç™½å¤©è¨è«–éšæ®µ</h3>
                <p className="text-gray-600 mb-4">è«‹æ‰€æœ‰ç©å®¶ç™¼è¨€ï¼Œè¨è«–èª°æ˜¯ç‹¼äººã€‚</p>
                <button onClick={startDayVoting} className="w-full py-3 mt-4 bg-red-500 text-white rounded-xl shadow-lg hover:bg-red-600">
                  é–‹å§‹æ”¾é€æŠ•ç¥¨
                </button>
              </div>
            )}
            
            {werewolfState.phase === 'day-voting' && (
                <div className="bg-white p-4 rounded-xl shadow-md text-center">
                    <h3 className="text-lg font-bold mb-2">æ”¾é€æŠ•ç¥¨</h3>
                    <p className="text-gray-600 mb-4">è«‹æ‰€æœ‰å­˜æ´»ç©å®¶æŠ•ç¥¨é¸å‡ºä½ æ‡·ç–‘çš„å°è±¡ã€‚</p>
                    <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
                        {alivePlayers.map(p => (
                            <div key={p.id} className="flex items-center space-x-2 p-2 bg-gray-100 rounded-lg">
                                <input type="radio" id={`vote-${p.id}`} name="vote" value={p.id} className="h-4 w-4 text-blue-600 focus:ring-blue-500" />
                                <label htmlFor={`vote-${p.id}`} className="text-lg font-medium text-gray-800">{p.name}</label>
                            </div>
                        ))}
                    </div>
                    <button onClick={handleVote} className="w-full py-3 mt-4 bg-red-500 text-white rounded-xl shadow-lg hover:bg-red-600">
                        ç¢ºèªæŠ•ç¥¨
                    </button>
                </div>
            )}

            {werewolfState.phase === 'day-end' && (
                <div className="bg-white p-4 rounded-xl shadow-md text-center">
                    <h3 className="text-lg font-bold mb-2">ç™½å¤©çµæŸ</h3>
                    <p className="text-gray-600 mb-4">
                        {werewolfState.votedOutPlayerId !== null
                            ? `ç¶“éæŠ•ç¥¨ï¼Œç©å®¶ ${players.find(p => p.id === werewolfState.votedOutPlayerId)?.name} å·²è¢«æ”¾é€ã€‚`
                            : `æŠ•ç¥¨å¾Œç„¡äººå‡ºå±€ã€‚`
                        }
                    </p>
                    <button 
                        onClick={() => setWerewolfState(prev => ({ ...prev, phase: 'night-intro', votedOutPlayerId: null }))} 
                        className="w-full py-3 mt-4 bg-gray-700 text-white rounded-xl shadow-lg hover:bg-black"
                    >
                        é€²å…¥å¤œæ™š
                    </button>
                </div>
            )}
            
            <button onClick={resetGame} className="w-full py-3 bg-gray-200 text-gray-800 rounded-xl shadow-md transition-all hover:bg-gray-300 mt-2">
              è¿”å›é¦–é 
            </button>
        </div>
    );
  };
  
  const History = () => (
    <div className="p-4 space-y-6">
      <div className="flex items-center justify-between">
        <button onClick={resetGame} className="text-gray-600 hover:text-gray-800 text-3xl">â¬…ï¸</button>
        <h2 className="text-2xl font-bold text-gray-800">éŠæˆ²ç´€éŒ„</h2>
        <div className="w-8"></div>
      </div>
      {gameHistory.length === 0 ? (
        <p className="text-center text-gray-500 mt-8">ç›®å‰æ²’æœ‰éŠæˆ²ç´€éŒ„ã€‚</p>
      ) : (
        gameHistory.map((entry, index) => (
          <div key={index} className="bg-white p-6 rounded-2xl shadow-md space-y-2">
            <div className="flex items-center justify-between font-bold text-gray-800">
              <span>{entry.gameMode}</span>
              <span>{entry.timestamp}</span>
            </div>
            <ul className="text-sm text-gray-600 space-y-1">
              {entry.players.map((p, i) => (
                <li key={i}>{p.name}: {p.role}</li>
              ))}
            </ul>
            <p className="text-right text-sm font-bold mt-2">çµæœ: {entry.result}</p>
          </div>
        ))
      )}
    </div>
  );
  
  const ResultScreen = () => {
    const getStatusText = (isAlive) => isAlive ? 'å­˜æ´»' : 'å·²å‡ºå±€';
    const getStatusIcon = (isAlive) => isAlive ? 'â¤ï¸' : 'ğŸ’€';
    const gameTitle = gameData[gameMode]?.name;
    
    const isGoodWin = gameResult.includes('æ­£ç¾©') || gameResult.includes('å¹³æ°‘') || gameResult.includes('å¥½äºº');
    const isEvilWin = gameResult.includes('é‚ªæƒ¡') || gameResult.includes('è‡¥åº•') || gameResult.includes('ç‹¼äºº');

    return (
        <div className="p-4 space-y-6 text-center">
            <h2 className="text-3xl font-bold text-gray-800 flex items-center justify-center">
                <span className="mr-2">ğŸ†</span>
                éŠæˆ²çµç®—
            </h2>
            <h3 className={`text-2xl font-bold ${isGoodWin ? 'text-blue-600' : isEvilWin ? 'text-red-600' : 'text-gray-700'}`}>
              {gameResult || `${gameTitle} éŠæˆ²çµæŸ`}
            </h3>
            <div className="bg-white p-6 rounded-2xl shadow-xl">
                <h4 className="text-lg font-bold mb-4">ç©å®¶æœ€çµ‚ç‹€æ…‹</h4>
                <ul className="space-y-4 text-left">
                    {players.map(p => {
                      const roleInfo = getPlayerRoleInfo(p.role);
                      let borderColor = '#e5e7eb';
                      let bgColor = '#f3f4f6';
                      let statusColor = 'text-gray-600';

                      if (gameMode === 'avalon') {
                        if (roleInfo?.side === 'good') {
                            borderColor = '#3b82f6'; bgColor = '#dbeafe';
                        } else if (roleInfo?.side === 'evil') {
                            borderColor = '#ef4444'; bgColor = '#fee2e2';
                        }
                      } else {
                        borderColor = p.alive ? '#4ade80' : '#f87171';
                        bgColor = p.alive ? '#dcfce7' : '#fee2e2';
                        statusColor = p.alive ? 'text-green-600' : 'text-red-600';
                      }

                      return (
                        <li key={p.id} className="flex items-center justify-between p-3 rounded-lg border-2" style={{ borderColor, backgroundColor: bgColor }}>
                            <div className="flex flex-col">
                                <span className="text-lg font-bold text-gray-800">{p.name}</span>
                                <span className="text-sm text-gray-600">
                                    èº«åˆ†: <span className="font-semibold">{roleInfo?.name}</span>
                                    {gameMode === 'whosTheSpy' && p.word && (
                                      <span className="ml-2">({p.word})</span>
                                    )}
                                </span>
                            </div>
                            {gameMode !== 'avalon' && (
                              <div className={`flex items-center text-sm font-bold ${statusColor}`}>
                                  <span className="inline-block mr-1">{getStatusIcon(p.alive)}</span>
                                  {getStatusText(p.alive)}
                              </div>
                            )}
                        </li>
                      );
                    })}
                </ul>
            </div>
            <button onClick={resetGame} className="w-full py-3 bg-indigo-500 text-white rounded-xl shadow-lg hover:bg-indigo-600 transition">
                è¿”å›ä¸»é¸å–®
            </button>
        </div>
    );
  };


  const resetGame = () => {
    setCurrentPage('home');
    setGameMode(null);
    setPlayers([]);
    setRoleCounts({});
    setPlayerCount(0);
    setCurrentPlayerIndex(0);
    setIsCardFlipped(false);
    setGameResult('');
    setAvalonState({
      leader: null,
      currentQuest: 0,
      team: [],
      questResults: [],
      voteCount: 0,
      currentVotePhase: 'team-selection',
      questVoteOutcome: null,
      missionVoteTally: { success: 0, fail: 0 },
      assassinationTarget: null,
      failedVotes: 0,
      questTeams: [],
      showQuestTeamModal: false,
      selectedQuestIndex: null
    });
    setWhosTheSpyState({ round: 1, turn: 0, descriptions: {}, phase: 'describing' });
    setWerewolfState({ day: 1, phase: 'night-intro', killedPlayerId: null, poisonedPlayerId: null, savedPlayerId: null, werewolfTargetId: null, seerTargetId: null, seerResult: null, guardianTargetId: null, killedList: [], playersToVote: [], votedOutPlayerId: null });
  };
  
  const fetchNewWords = async () => {
    setIsFetchingWords(true);
    showMessageWithTimeout('æ­£åœ¨å–å¾—æ–°è©èª...');
    const prompt = "Generate 5 pairs of related words suitable for the 'Who's the Spy' game in Traditional Chinese. Each pair should consist of two words that are similar but not identical. The output should be a JSON array of arrays, like [['word1', 'word2'], ['word3', 'word4'], ...]. The words should be common nouns.";
    const apiKey = "AIzaSyCEIsgA8IDtFfJX1sNNv48xnm1TTYKInm4";
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

    const payload = {
        contents: [{ parts: [{ text: prompt }] }],
        generationConfig: {
            responseMimeType: "application/json",
            responseSchema: {
                type: "ARRAY",
                items: {
                    type: "ARRAY",
                    items: { "type": "STRING" },
                    minItems: 2,
                    maxItems: 2
                },
                minItems: 5,
                maxItems: 5
            }
        }
    };

    try {
        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
        const result = await response.json();
        const jsonText = result?.candidates?.[0]?.content?.parts?.[0]?.text;
        const newWords = JSON.parse(jsonText);

        if (Array.isArray(newWords) && newWords.length > 0) {
            gameData.whosTheSpy.words = newWords;
            showMessageWithTimeout('æˆåŠŸå–å¾—æ–°è©èªï¼');
        } else {
            showMessageWithTimeout('å–å¾—è©èªå¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚');
        }
    } catch (error) {
        console.error("Failed to fetch new words:", error);
        showMessageWithTimeout('é€£ç·šéŒ¯èª¤ï¼Œç„¡æ³•å–å¾—æ–°è©èªã€‚è«‹æª¢æŸ¥ç¶²è·¯é€£ç·šã€‚');
    } finally {
        setIsFetchingWords(false);
    }
  };


  return (
    <div className="font-sans antialiased bg-gray-100 min-h-screen flex items-center justify-center p-4">
      <div className="bg-white rounded-3xl shadow-2xl p-6 md:p-10 w-full max-w-lg text-center transform transition-all duration-300">
        <header className="mb-8">
          <h1 className="text-4xl md:text-5xl font-extrabold text-indigo-600">
            <span className="inline-block mr-2 text-5xl">ğŸ®</span>
            æ¡ŒéŠåŠ©æ‰‹
          </h1>
          <p className="mt-2 text-gray-500 text-lg">å–®æ©Ÿç‰ˆ</p>
        </header>
        <div className="relative">
          {message && (
            <div className="absolute top-0 left-1/2 -translate-x-1/2 z-50 p-3 bg-red-500 text-white rounded-lg shadow-xl text-center transition-all duration-300">
              {message}
            </div>
          )}
        </div>
        <div className="animate-fade-in">
          {currentPage === 'home' && <Home />}
          {currentPage === 'setup' && <Setup />}
          {currentPage === 'role-reveal' && <RoleReveal />}
          {currentPage === 'whos-the-spy-gameplay' && <WhosTheSpyGameplay />}
          {currentPage === 'avalon-gameplay' && <AvalonGameplay />}
          {currentPage === 'werewolf-gameplay' && <WerewolfGameplay />}
          {currentPage === 'history' && <History />}
          {currentPage === 'result-screen' && <ResultScreen />}
        </div>
      </div>
    </div>
  );
};

ReactDOM.render(<App />, document.getElementById('root'));

