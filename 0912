const { useState, useEffect } = React;

// ÂÖ±ÂêåÂäüËÉΩÔºöÊ¥óÁâåÈô£Âàó
const shuffleArray = (array) => {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
};

// ÊâÄÊúâÈÅäÊà≤Ë≥áÊñôÂÆöÁæ©ÈõÜ‰∏≠ÊñºÊ≠§
const gameData = {
  whosTheSpy: {
    name: 'Ë™∞ÊòØËá•Â∫ï',
    icon: 'üëª',
    roles: [
      { name: 'Âπ≥Ê∞ë', icon: 'üë§', code: 'civilian', description: 'ËàáÂÖ∂‰ªñÂπ≥Ê∞ëÁç≤ÂæóÁõ∏ÂêåË©ûË™û„ÄÇ', side: 'good' },
      { name: 'Ëá•Â∫ï', icon: '‚öîÔ∏è', code: 'spy', description: 'Áç≤ÂæóËàáÂπ≥Ê∞ë‰∏çÂêåÁöÑË©ûË™û„ÄÇ', side: 'evil' },
      { name: 'ÁôΩÊùø', icon: 'üö´', code: 'blank', description: 'ÂÆåÂÖ®Ê≤íÊúâË©ûË™ûÔºåÈúÄÈÄèÈÅéÁåúÊ∏¨‰æÜÈö±ËóèË∫´ÂàÜ„ÄÇ', side: 'neutral' }
    ],
    words: [
      ['ÁâõÂ•∂', 'ÁæäÂ•∂'], ['ÂèØÂè£ÂèØÊ®Ç', 'Áôæ‰∫ãÂèØÊ®Ç'], ['Á≠ÜË®òÊú¨', 'Ë®ò‰∫ãÊú¨'],
      ['ÂÜ∞Ê∑áÊ∑ã', 'Èõ™Á≥ï'], ['Ë•øÁìú', 'ÂÜ¨Áìú'], ['ÈâõÁ≠Ü', 'ÂéüÂ≠êÁ≠Ü'],
      ['Êº¢Â†°', '‰∏âÊòéÊ≤ª'], ['È∫ªÁ≥¨', 'ÊπØÂúì'], ['Ëë°ËêÑÊüö', 'Ê©òÂ≠ê'],
      ['È∫µÊ¢ù', 'ÊãâÈ∫µ'], ['Â§™ÈôΩ', 'Êúà‰∫Æ'], ['ÊâãÊ©ü', 'Âπ≥ÊùøÈõªËÖ¶'],
      ['ÂÜ∞ÁÆ±', 'ÂÜ∑Ê∞£Ê©ü'], ['Ê£âËä±Á≥ñ', 'Êµ∑Á∂øËõãÁ≥ï'], ['Ê¥óÈù¢‰π≥', 'Ê≤êÊµ¥‰π≥'],
      ['È∫•ÂÖãÈ¢®', 'Êì¥Èü≥Âô®'], ['Èë∞Âåô', 'ÈéñÈ†≠'], ['Áï™ËåÑ', 'ËçâËéì']
    ],
    playerConfigs: {
      4: { civilian: 3, spy: 1 }, 5: { civilian: 4, spy: 1 },
      6: { civilian: 4, spy: 1, blank: 1 },
      7: { civilian: 5, spy: 2 }, 8: { civilian: 6, spy: 2 },
      9: { civilian: 7, spy: 2 }, 10: { civilian: 8, spy: 2 }
    }
  },
  werewolf: {
    name: 'Áãº‰∫∫ÊÆ∫',
    icon: 'ü™ì',
    roles: [
      { name: 'Áãº‰∫∫', icon: 'ü™ì', code: 'werewolf', description: 'Âú®Â§úÊôöÊÆ∫ÂÆ≥Âπ≥Ê∞ë„ÄÇ', side: 'evil' },
      { name: 'Âπ≥Ê∞ë', icon: 'üë§', code: 'civilian', description: 'ÁôΩÂ§©ÁôºË®Ä‰∏¶ÊäïÁ•®ÊâæÂá∫Áãº‰∫∫„ÄÇ', side: 'good' },
      { name: 'È†êË®ÄÂÆ∂', icon: 'üëÅÔ∏è', code: 'seer', description: 'ÊØèÊôöÊü•È©ó‰∏Ä‰∫∫Ë∫´ÂàÜ„ÄÇ', side: 'good' },
      { name: 'Â•≥Â∑´', icon: 'üõ°Ô∏è', code: 'witch', description: 'ÊúâËß£Ëó•ÂíåÊØíËó•ÂêÑ‰∏ÄÁì∂„ÄÇ', side: 'good' },
      { name: 'Áçµ‰∫∫', icon: 'üéØ', code: 'hunter', description: 'Ê≠ªÂæåÂèØ‰ª•ÈñãÊßçÂ∏∂Ëµ∞‰∏Ä‰∫∫„ÄÇ', side: 'good' },
      { name: 'ÈÇ±ÊØîÁâπ', icon: '‚ù§Ô∏è', code: 'cupid', description: 'ÈÄ£ÁµêÂÖ©‰∫∫ÊàêÁÇ∫ÊÉÖ‰æ∂„ÄÇ', side: 'good' },
      { name: 'ÁãºÁéã', icon: 'üëë', code: 'wolf_king', description: 'Ê≠ªÂæåÂèØ‰ª•ÈñãÊßçÂ∏∂Ëµ∞‰∏Ä‰∫∫„ÄÇ', side: 'evil' },
      { name: 'ÂÆàË°õ', icon: 'üõ°Ô∏è‚úÖ', code: 'guardian', description: 'ÊØèÊôöÂèØ‰ª•ÂÆàË≠∑‰∏Ä‰∫∫„ÄÇ', side: 'good' },
      { name: 'ÁôΩÁô°', icon: 'üõ°Ô∏è‚ùå', code: 'idiot', description: 'Ë¢´ÊäïÁ•®Âá∫Â±ÄÂæåÂèØÁøªÁâåÂÖçÊ≠ª„ÄÇ', side: 'good' }
    ],
    playerConfigs: {
      6: { werewolf: 2, civilian: 2, seer: 1, witch: 1 },
      7: { werewolf: 2, civilian: 3, seer: 1, witch: 1 },
      8: { werewolf: 2, civilian: 3, seer: 1, witch: 1, hunter: 1 },
      9: { werewolf: 3, civilian: 3, seer: 1, witch: 1, hunter: 1 },
      10: { werewolf: 3, civilian: 3, seer: 1, witch: 1, hunter: 1, cupid: 1 },
      12: { werewolf: 4, civilian: 4, seer: 1, witch: 1, hunter: 1, cupid: 1, guardian: 1 },
      14: { werewolf: 4, civilian: 5, seer: 1, witch: 1, hunter: 1, cupid: 1, guardian: 1, idiot: 1 }
    }
  },
  avalon: {
    name: 'ÈòøÁì¶ÈöÜ',
    icon: 'üó°Ô∏è',
    roles: [
      { name: 'Ê¢ÖÊûó', icon: 'üëë', code: 'merlin', description: 'Ê≠£Áæ©ÊñπÈ†òË¢ñÔºåÁü•ÈÅìÈÇ™ÊÉ°Ë∫´ÂàÜ„ÄÇ', side: 'good' },
      { name: 'Âà∫ÂÆ¢', icon: '‚öîÔ∏è', code: 'assassin', description: 'ÈÇ™ÊÉ°ÊñπÔºåËã•Ê≠£Áæ©ÊàêÂäüÂèØÂà∫ÊÆ∫Ê¢ÖÊûó„ÄÇ', side: 'evil' },
      { name: 'Ê¥æË•øÁ∂≠Áàæ', icon: 'üëÅÔ∏è', code: 'percival', description: 'Áü•ÈÅìÊ¢ÖÊûóËàáËé´ÁîòÂ®úË∫´ÂàÜ„ÄÇ', side: 'good' },
      { name: 'Ëé´ÁîòÂ®ú', icon: 'üëª', code: 'morgana', description: 'ÈÇ™ÊÉ°ÊñπÔºåÂÅΩË£ùÊàêÊ¢ÖÊûó„ÄÇ', side: 'evil' },
      { name: 'Â•ß‰ºØÂÄ´', icon: '‚ùì', code: 'oberon', description: 'ÈÇ™ÊÉ°ÊñπÔºå‰ΩÜ‰∏çÁü•ÈÅìÈÇ™ÊÉ°Âêå‰º¥„ÄÇ', side: 'evil' },
      { name: 'Ëé´Âæ∑Èõ∑Âæ∑', icon: 'üîí', code: 'mordred', description: 'ÈÇ™ÊÉ°ÊñπÔºåÊ¢ÖÊûóÁÑ°Ê≥ïÂÅµÊ∏¨„ÄÇ', side: 'evil' },
      { name: 'Âø†Ëá£', icon: 'üõ°Ô∏è‚úÖ', code: 'servant', description: 'Ê≠£Áæ©ÊñπÔºåÂø†Ë™†Êñº‰∫ûÁëüÁéã„ÄÇ', side: 'good' },
      { name: 'Áà™Áâô', icon: 'üó°Ô∏è', code: 'minion', description: 'ÈÇ™ÊÉ°ÊñπÔºåÂø†Ë™†ÊñºËé´Âæ∑Èõ∑Âæ∑„ÄÇ', side: 'evil' }
    ],
    playerConfigs: {
      5: { servant: 2, merlin: 1, minion: 1, assassin: 1 },
      6: { servant: 2, merlin: 1, percival: 1, morgana: 1, assassin: 1 },
      7: { servant: 2, merlin: 1, percival: 1, morgana: 1, assassin: 1, oberon: 1 },
      8: { servant: 3, merlin: 1, percival: 1, morgana: 1, assassin: 1, mordred: 1 },
      9: { servant: 4, merlin: 1, percival: 1, morgana: 1, assassin: 1, mordred: 1 },
      10: { servant: 4, merlin: 1, percival: 1, morgana: 1, assassin: 1, mordred: 1, oberon: 1 }
    },
    questSizes: {
      5: [2, 3, 2, 3, 3],
      6: [2, 3, 4, 3, 4],
      7: [2, 3, 3, 4, 4],
      8: [3, 4, 4, 5, 5],
      9: [3, 4, 4, 5, 5],
      10: [3, 4, 4, 5, 5]
    }
  }
};

const getDefaultRoles = (mode, count) => {
  const config = gameData[mode].playerConfigs[count] || {};
  return Object.keys(config).map(roleCode => ({
    code: roleCode,
    count: config[roleCode]
  }));
};

const App = () => {
  const [currentPage, setCurrentPage] = useState('home');
  const [gameMode, setGameMode] = useState(null);
  const [players, setPlayers] = useState([]);
  const [roleCounts, setRoleCounts] = useState({});
  const [playerCount, setPlayerCount] = useState(0);
  const [currentPlayerIndex, setCurrentPlayerIndex] = useState(0);
  const [isCardFlipped, setIsCardFlipped] = useState(false);
  const [message, setMessage] = useState('');
  const [isFetchingWords, setIsFetchingWords] = useState(false);
  const [gameHistory, setGameHistory] = useState([]);
  const [gameResult, setGameResult] = useState('');

  // Avalon specific states
  const [avalonState, setAvalonState] = useState({
    leader: null,
    currentQuest: 0,
    team: [],
    questResults: [],
    voteCount: 0,
    currentVotePhase: 'team-selection',
    questVoteOutcome: null,
    missionVoteTally: { success: 0, fail: 0 },
    assassinationTarget: null,
    failedVotes: 0,
    questTeams: [],
    showQuestTeamModal: false,
    selectedQuestIndex: null
  });

  // Whos the Spy specific states
  const [whosTheSpyState, setWhosTheSpyState] = useState({
    round: 1,
    turn: 0,
    descriptions: {},
    phase: 'describing',
  });

  // Werewolf specific states
  const [werewolfState, setWerewolfState] = useState({
    day: 1,
    phase: 'night-intro',
    killedPlayerId: null,
    poisonedPlayerId: null,
    savedPlayerId: null,
    witchHasAntidote: true,
    witchHasPoison: true,
    werewolfTargetId: null,
    seerTargetId: null,
    seerResult: null,
    guardianTargetId: null,
    killedList: [],
    playersToVote: [],
    votedOutPlayerId: null
  });

  // Âæû localStorage ËºâÂÖ•ÈÅäÊà≤Ê≠∑Âè≤Á¥ÄÈåÑ
  useEffect(() => {
    try {
      const history = JSON.parse(localStorage.getItem('gameHistory')) || [];
      setGameHistory(history);
    } catch (e) {
      console.error("Failed to load game history from localStorage", e);
    }
  }, []);

  const showMessageWithTimeout = (msg) => {
    setMessage(msg);
    setTimeout(() => setMessage(''), 3000);
  };
  
  const saveGameHistory = (result) => {
    const newHistory = {
        gameMode: gameData[gameMode].name,
        timestamp: new Date().toLocaleString(),
        players: players.map(p => ({ name: p.name, role: gameData[gameMode].roles.find(r => r.code === p.role)?.name })),
        result: result
    };
    const updatedHistory = [newHistory, ...gameHistory];
    setGameHistory(updatedHistory);
    localStorage.setItem('gameHistory', JSON.stringify(updatedHistory));
  };


  const setupGame = (mode) => {
    setGameMode(mode);
    const defaultCount = Object.keys(gameData[mode].playerConfigs)[0];
    setPlayerCount(parseInt(defaultCount));
    updateRoleCounts(mode, parseInt(defaultCount));
    setCurrentPage('setup');
  };

  const updateRoleCounts = (mode, count) => {
    const roles = getDefaultRoles(mode, count);
    const newCounts = {};
    roles.forEach(role => newCounts[role.code] = role.count);
    setRoleCounts(newCounts);
  };

  const handleStartGame = () => {
    const totalPlayers = Object.values(roleCounts).reduce((sum, count) => sum + count, 0);
    if (totalPlayers === 0 || totalPlayers !== playerCount) {
      showMessageWithTimeout('Á∏Ω‰∫∫Êï∏ËàáËßíËâ≤Êï∏Èáè‰∏çÁ¨¶ÔºÅ');
      return;
    }

    let rolesToAssign = [];
    for (const role in roleCounts) {
      for (let i = 0; i < roleCounts[role]; i++) {
        rolesToAssign.push(role);
      }
    }
    shuffleArray(rolesToAssign);

    const initialPlayers = Array.from({ length: playerCount }, (_, i) => ({
      id: i,
      name: `Áé©ÂÆ∂ ${i + 1}`,
      role: rolesToAssign[i],
      revealed: false,
      word: null,
      alive: true
    }));

    if (gameMode === 'whosTheSpy') {
      const selectedWords = gameData.whosTheSpy.words[Math.floor(Math.random() * gameData.whosTheSpy.words.length)];
      initialPlayers.forEach(player => {
        if (player.role === 'spy') {
          player.word = selectedWords[1];
        } else if (player.role === 'civilian') {
          player.word = selectedWords[0];
        } else if (player.role === 'blank') {
          player.word = null;
        }
      });
      setWhosTheSpyState({ round: 1, turn: 0, descriptions: {}, phase: 'describing' });
    }

    if (gameMode === 'avalon') {
      const initialLeaderIndex = Math.floor(Math.random() * playerCount);
      setAvalonState({
        ...avalonState,
        leader: initialPlayers[initialLeaderIndex].id,
        currentQuest: 1,
        currentVotePhase: 'team-selection'
      });
    }

    if (gameMode === 'werewolf') {
      setWerewolfState({
        day: 1,
        phase: 'night-intro',
        killedPlayerId: null,
        poisonedPlayerId: null,
        savedPlayerId: null,
        witchHasAntidote: true,
        witchHasPoison: true,
        werewolfTargetId: null,
        seerTargetId: null,
        seerResult: null,
        guardianTargetId: null,
        killedList: [],
        playersToVote: [],
        votedOutPlayerId: null
      });
    }

    setPlayers(initialPlayers);
    setIsCardFlipped(false);
    setCurrentPlayerIndex(0);
    setCurrentPage('role-reveal');
  };

  const nextPlayerReveal = () => {
    setIsCardFlipped(false);
    if (currentPlayerIndex < players.length - 1) {
      setCurrentPlayerIndex(prev => prev + 1);
    } else {
      setCurrentPage(
        gameMode === 'avalon' ? 'avalon-gameplay' :
        gameMode === 'whosTheSpy' ? 'whos-the-spy-gameplay' :
        'werewolf-gameplay'
      );
    }
  };
  
  const getPlayerRoleInfo = (roleCode) => {
    return gameData[gameMode]?.roles.find(r => r.code === roleCode);
  };
  
  const endGame = (result) => {
      setGameResult(result);
      saveGameHistory(result);
      setCurrentPage('result-screen');
  };


  // --- Avalon Logic ---
  const togglePlayerSelection = (playerId) => {
    setAvalonState(prev => {
      const teamSize = gameData.avalon.questSizes[playerCount][prev.currentQuest - 1];
      const newTeam = prev.team.includes(playerId)
        ? prev.team.filter(id => id !== playerId)
        : [...prev.team, playerId];
      if (newTeam.length > teamSize) {
        showMessageWithTimeout(`‰ªªÂãôÈöä‰ºç‰∏äÈôêÁÇ∫ ${teamSize} ‰∫∫`);
        return prev;
      }
      return { ...prev, team: newTeam };
    });
  };

  const startAvalonTeamVote = () => {
    setAvalonState(prev => ({ ...prev, currentVotePhase: 'team-voting', voteTally: { approve: 0, reject: 0 } }));
    showMessageWithTimeout('È†òË¢ñÂ∑≤ÁôºËµ∑ÂúòÈöäÊäïÁ•®ÔºÅ');
  };

  const recordAvalonTeamVote = (outcome) => {
    setAvalonState(prev => {
      const newTally = { ...prev.voteTally };
      newTally[outcome]++;
      const totalVotes = newTally.approve + newTally.reject;
      const majority = playerCount / 2;
      const isMajority = newTally.approve > majority;

      if (totalVotes === playerCount) {
        if (isMajority) {
          showMessageWithTimeout('ÂúòÈöäÊäïÁ•®ÈÄöÈÅéÔºÅÊ∫ñÂÇôÂá∫ÁôºÂü∑Ë°å‰ªªÂãô„ÄÇ');
          return {
            ...prev,
            voteTally: newTally,
            currentVotePhase: 'mission-voting',
            failedVotes: 0,
            questTeams: [...(prev.questTeams || []), { quest: prev.currentQuest, members: prev.team }]
          };
        } else {
          showMessageWithTimeout('ÂúòÈöäÊäïÁ•®Êú™ÈÄöÈÅé„ÄÇÊõ¥ÊèõÈ†òË¢ñÔºåÈáçÊñ∞ÁµÑÈöä„ÄÇ');
          const newLeaderIndex = (players.findIndex(p => p.id === prev.leader) + 1) % playerCount;
          const newFailedVotes = prev.failedVotes + 1;
          if (newFailedVotes >= 5) {
            endGame('ÈÇ™ÊÉ°ÊñπÁç≤Âãù');
            return {
              ...prev,
              currentVotePhase: 'evil-wins',
              failedVotes: newFailedVotes
            };
          }
          return {
            ...prev,
            voteTally: newTally,
            currentVotePhase: 'team-selection',
            failedVotes: newFailedVotes,
            leader: players[newLeaderIndex].id,
            team: []
          };
        }
      }
      return { ...prev, voteTally: newTally };
    });
  };

  const startAvalonMissionVote = () => {
    setAvalonState(prev => ({ ...prev, currentVotePhase: 'mission-voting' }));
  };

  const recordAvalonMissionVote = (outcome) => {
    setAvalonState(prev => {
      const newVoteTally = { ...prev.missionVoteTally };
      if (outcome === 'success') {
        newVoteTally.success++;
      } else {
        newVoteTally.fail++;
      }
      if (newVoteTally.success + newVoteTally.fail === prev.team.length) {
        return {
          ...prev,
          missionVoteTally: newVoteTally,
          currentVotePhase: 'mission-result'
        };
      }
      return { ...prev, missionVoteTally: newVoteTally };
    });
  };

  const advanceAvalonQuest = () => {
    setAvalonState(prev => {
      const { missionVoteTally, currentQuest } = prev;
      const failVotesNeeded = (playerCount >= 7 && currentQuest === 4) ? 2 : 1;
      const isSuccess = missionVoteTally.fail < failVotesNeeded;
      
      const newResults = [...prev.questResults, isSuccess ? 'success' : 'fail'];
      const newLeaderIndex = (players.findIndex(p => p.id === prev.leader) + 1) % playerCount;
      const goodWins = newResults.filter(r => r === 'success').length === 3;
      const evilWins = newResults.filter(r => r === 'fail').length === 3;

      let nextState = {
        ...prev,
        questResults: newResults,
        team: [],
        missionVoteTally: { success: 0, fail: 0 },
        leader: players[newLeaderIndex].id,
        currentQuest: prev.currentQuest + 1
      };

      if (goodWins) {
        nextState.currentVotePhase = 'assassination';
      } else if (evilWins) {
        nextState.currentVotePhase = 'evil-wins';
        endGame('ÈÇ™ÊÉ°ÊñπÁç≤Âãù');
      } else {
        nextState.currentVotePhase = 'team-selection';
      }
      return nextState;
    });
  };

  const assassinatePlayer = (playerId) => {
    const targetPlayer = players.find(p => p.id === playerId);
    let outcomeMessage = '';
    let finalPhase = '';

    if (targetPlayer.role === 'merlin') {
      outcomeMessage = 'Âà∫ÂÆ¢ÊàêÂäüÂà∫ÊÆ∫Ê¢ÖÊûóÔºåÈÇ™ÊÉ°ÊñπÁç≤ÂãùÔºÅ';
      finalPhase = 'evil-wins';
      endGame('ÈÇ™ÊÉ°ÊñπÁç≤Âãù');
    } else {
      outcomeMessage = 'Âà∫ÂÆ¢Âà∫ÊÆ∫Â§±ÊïóÔºåÊ≠£Áæ©ÊñπÁç≤ÂãùÔºÅ';
      finalPhase = 'good-wins';
      endGame('Ê≠£Áæ©ÊñπÁç≤Âãù');
    }

    showMessageWithTimeout(outcomeMessage);
    setAvalonState(prev => ({ ...prev, assassinationTarget: playerId, currentVotePhase: finalPhase }));
  };

  const showQuestTeamModal = (index) => {
    setAvalonState(prev => ({ ...prev, showQuestTeamModal: true, selectedQuestIndex: index }));
  };
  const hideQuestTeamModal = () => {
    setAvalonState(prev => ({ ...prev, showQuestTeamModal: false, selectedQuestIndex: null }));
  };


  // --- Who's the Spy Logic ---
  const startWhosTheSpyTurn = () => {
    setWhosTheSpyState(prev => ({ ...prev, turn: 0, phase: 'describing' }));
    setCurrentPage('whos-the-spy-gameplay');
  };

  const nextWhosTheSpyTurn = () => {
    setWhosTheSpyState(prev => {
      const alivePlayers = players.filter(p => p.alive);
      const nextTurn = prev.turn + 1;
      if (nextTurn >= alivePlayers.length) {
        return { ...prev, phase: 'voting' };
      }
      return { ...prev, turn: nextTurn };
    });
  };

  const recordWhosTheSpyDescription = (playerId, description) => {
    setWhosTheSpyState(prev => ({
      ...prev,
      descriptions: {
        ...prev.descriptions,
        [playerId]: description
      }
    }));
  };

  const processWhosTheSpyVote = (votes) => {
    const voteCounts = {};
    votes.forEach(playerId => {
      voteCounts[playerId] = (voteCounts[playerId] || 0) + 1;
    });

    const maxVotes = Math.max(...Object.values(voteCounts));
    const playersWithMaxVotes = Object.keys(voteCounts).filter(id => voteCounts[id] === maxVotes);

    if (playersWithMaxVotes.length > 1) {
      showMessageWithTimeout('ÊäïÁ•®Âπ≥ÊâãÔºåË´ãÂÜçÊ¨°ÈÄ≤Ë°åÊäïÁ•®ÔºÅ');
      return;
    }
    
    const eliminatedPlayerId = parseInt(playersWithMaxVotes[0]);
    const eliminatedPlayer = players.find(p => p.id === eliminatedPlayerId);
    
    const newPlayers = players.map(p =>
      p.id === eliminatedPlayerId ? { ...p, alive: false } : p
    );
    setPlayers(newPlayers);

    showMessageWithTimeout(`Áé©ÂÆ∂ ${eliminatedPlayer.name} Â∑≤Ë¢´Ê∑òÊ±∞ÔºÅ‰ªñÁöÑË∫´‰ªΩÊòØÔºö${gameData.whosTheSpy.roles.find(r => r.code === eliminatedPlayer.role)?.name}`);
    
    checkWhosTheSpyWin(newPlayers);
  };

  const checkWhosTheSpyWin = (currentPlayers) => {
    const alivePlayers = currentPlayers.filter(p => p.alive);
    const aliveRoles = alivePlayers.map(p => p.role);
    const aliveSpies = aliveRoles.filter(role => role === 'spy').length;
    const aliveBlanks = aliveRoles.filter(role => role === 'blank').length;
    const totalAlive = alivePlayers.length;
    const initialPlayerCount = currentPlayers.length;
    
    let winner = null;
    let winnerMessage = '';

    const spyWinCondition = (initialPlayerCount === 4 && totalAlive <= 2) || (initialPlayerCount > 4 && totalAlive <= 3);

    if (spyWinCondition && aliveSpies > 0) {
        winner = 'Ëá•Â∫ï';
        winnerMessage = 'ÊÅ≠ÂñúËá•Â∫ïÊñπÁç≤ÂãùÔºÅ';
    } else if (aliveSpies === 0 && aliveBlanks > 0) {
        winner = 'ÁôΩÊùø';
        winnerMessage = 'ÁôΩÊùøÊñπÁç≤ÂãùÔºÅ';
    } else if (aliveSpies === 0) {
        winner = 'Âπ≥Ê∞ë';
        winnerMessage = 'ÊÅ≠ÂñúÂπ≥Ê∞ëÊñπÁç≤ÂãùÔºÅ';
    }

    if (winner) {
        const result = `${winner} Èô£ÁáüÁç≤Âãù`;
        showMessageWithTimeout(winnerMessage);
        endGame(result);
    } else {
        setWhosTheSpyState(prev => ({ ...prev, round: prev.round + 1, turn: 0, descriptions: {}, phase: 'describing' }));
    }
  };


  // --- Werewolf Logic ---
  const startWerewolfGame = () => {
    setWerewolfState({
        day: 1,
        phase: 'night-intro',
        killedPlayerId: null,
        poisonedPlayerId: null,
        savedPlayerId: null,
        witchHasAntidote: true,
        witchHasPoison: true,
        werewolfTargetId: null,
        seerTargetId: null,
        seerResult: null,
        guardianTargetId: null,
        killedList: [],
        playersToVote: [],
        votedOutPlayerId: null
    });
    setCurrentPage('werewolf-gameplay');
  };

  const checkWerewolfWin = (currentPlayers) => {
    const alivePlayers = currentPlayers.filter(p => p.alive);
    
    const evilRoles = gameData.werewolf.roles.filter(r => r.side === 'evil').map(r => r.code);
    const godRoles = gameData.werewolf.roles.filter(r => r.side === 'good' && r.code !== 'civilian').map(r => r.code);

    const hadGodsInitially = players.some(p => godRoles.includes(p.role));
    const hadCiviliansInitially = players.some(p => p.role === 'civilian');

    const aliveWolves = alivePlayers.filter(p => evilRoles.includes(p.role)).length;
    const aliveGods = alivePlayers.filter(p => godRoles.includes(p.role)).length;
    const aliveCivilians = alivePlayers.filter(p => p.role === 'civilian').length;
    
    let winner = null;

    if (aliveWolves === 0) {
        winner = 'Â•Ω‰∫∫Èô£ÁáüÁç≤Âãù';
    } else if ((hadGodsInitially && aliveGods === 0) || (hadCiviliansInitially && aliveCivilians === 0)) {
        winner = 'Áãº‰∫∫Èô£ÁáüÁç≤Âãù';
    }
    
    if(winner) {
      showMessageWithTimeout(`${winner}ÔºÅ`);
      endGame(winner);
      return true;
    }
    return false;
  };
  
  const endNight = () => {
    setWerewolfState(prev => {
        const { werewolfTargetId, savedPlayerId, poisonedPlayerId, guardianTargetId } = prev;
        
        const killedThisNight = [];
        if (werewolfTargetId && savedPlayerId !== werewolfTargetId && guardianTargetId !== werewolfTargetId) {
            killedThisNight.push(werewolfTargetId);
        }
        if (poisonedPlayerId) {
            killedThisNight.push(poisonedPlayerId);
        }
        const uniqueKilled = [...new Set(killedThisNight)];

        const nightMessage = uniqueKilled.length > 0 ? "Êò®Êôö‰∏çÊòØ‰∏ÄÂÄãÂπ≥ÂÆâÂ§ú..." : "Â§©‰∫Æ‰∫ÜÔºåÊò®ÊôöÊòØÂÄãÂπ≥ÂÆâÂ§ú„ÄÇ";
        
        const newPlayers = players.map(p => 
            uniqueKilled.includes(p.id) ? { ...p, alive: false } : p
        );
        
        setPlayers(newPlayers);
        showMessageWithTimeout(nightMessage);

        if (checkWerewolfWin(newPlayers)) {
          return { ...prev, phase: 'end' };
        }
        
        return {
            ...prev,
            day: prev.day + 1,
            phase: 'day-announcement',
            killedList: uniqueKilled,
            werewolfTargetId: null,
            poisonedPlayerId: null,
            savedPlayerId: null,
            seerResult: null,
            guardianTargetId: null
        };
    });
  };

  const handleWerewolfAction = (targetId, role) => {
    const alivePlayers = players.filter(p => p.alive);
    switch (role) {
        case 'werewolf':
            setWerewolfState(prev => ({ ...prev, werewolfTargetId: targetId, phase: 'night-seer-intro' }));
            break;
        case 'seer':
            const targetRole = players.find(p => p.id === targetId)?.role;
            const isWolf = ['werewolf', 'wolf_king'].includes(targetRole);
            const resultMessage = isWolf ? `Êü•È©óÂ∞çË±° ${players.find(p => p.id === targetId)?.name} ÊòØÁãº‰∫∫„ÄÇ` : `Êü•È©óÂ∞çË±° ${players.find(p => p.id === targetId)?.name} ÊòØÂ•Ω‰∫∫„ÄÇ`;
            setWerewolfState(prev => ({ ...prev, seerTargetId: targetId, seerResult: resultMessage }));
            break;
        case 'witch-antidote':
            setWerewolfState(prev => ({ ...prev, savedPlayerId: prev.werewolfTargetId, witchHasAntidote: false, phase: 'night-end' }));
            break;
        case 'witch-poison':
            setWerewolfState(prev => ({ ...prev, poisonedPlayerId: targetId, witchHasPoison: false, phase: 'night-end' }));
            break;
        default:
            break;
    }
  };
  
  const startDayDiscussion = () => {
      setWerewolfState(prev => ({...prev, phase: 'day-discussion'}));
  };

  const startDayVoting = () => {
    const alivePlayers = players.filter(p => p.alive);
    setWerewolfState(prev => ({ ...prev, phase: 'day-voting', playersToVote: alivePlayers.map(p => p.id) }));
  };

  const processWerewolfVote = (votes) => {
    const voteCounts = {};
    votes.forEach(playerId => {
      voteCounts[playerId] = (voteCounts[playerId] || 0) + 1;
    });

    const maxVotes = Math.max(...Object.values(voteCounts));
    const playersWithMaxVotes = Object.keys(voteCounts).filter(id => voteCounts[id] === maxVotes);

    if (playersWithMaxVotes.length > 1) {
      showMessageWithTimeout('ÊäïÁ•®Âπ≥ÊâãÔºåË´ãÂÜçÊ¨°ÈÄ≤Ë°åÊäïÁ•®ÔºÅ');
      return;
    }
    
    const eliminatedPlayerId = parseInt(playersWithMaxVotes[0]);
    const eliminatedPlayer = players.find(p => p.id === eliminatedPlayerId);
    
    let hunterShotId = null;
    let wolfKingShotId = null;
    let idiotSaved = false;

    if (eliminatedPlayer?.role === 'idiot') {
        idiotSaved = window.confirm(`Áé©ÂÆ∂ ${eliminatedPlayer.name} (ÁôΩÁô°) Ë¢´ÊäïÁ•®Âá∫Â±Ä‰∫ÜÔºåÊòØÂê¶ÁøªÁâåÂÖçÊ≠ªÔºü`);
        if (idiotSaved) {
            showMessageWithTimeout('ÁôΩÁô°ÊàêÂäüÁøªÁâåÔºåÂÖçÊñºÂá∫Â±ÄÔºÅ');
            setWerewolfState(prev => ({ ...prev, phase: 'day-end', votedOutPlayerId: null }));
            return;
        }
    }
    
    if (eliminatedPlayer?.role === 'hunter' || eliminatedPlayer?.role === 'wolf_king') {
        const targetName = prompt(`Áé©ÂÆ∂ ${eliminatedPlayer.name} (Áçµ‰∫∫/ÁãºÁéã) Ê±∫ÂÆöÈñãÊßçÔºåË´ãÈÅ∏ÊìáË¶ÅÂ∏∂Ëµ∞ÁöÑÁé©ÂÆ∂ÂêçÁ®±Ôºö`);
        const targetPlayer = players.find(p => p.name === targetName && p.alive);
        if (targetPlayer && targetPlayer.id !== eliminatedPlayerId) {
            if (eliminatedPlayer.role === 'hunter') hunterShotId = targetPlayer.id;
            else wolfKingShotId = targetPlayer.id;
        }
    }
    
    const newPlayers = players.map(p => {
        let newP = { ...p };
        if (p.id === eliminatedPlayerId || p.id === hunterShotId || p.id === wolfKingShotId) {
            newP.alive = false;
        }
        return newP;
    });

    setPlayers(newPlayers);
    
    showMessageWithTimeout(`Áé©ÂÆ∂ ${eliminatedPlayer.name} Ë¢´ÊäïÁ•®Âá∫Â±Ä‰∫Ü„ÄÇ`);
    if (hunterShotId) showMessageWithTimeout(`Áçµ‰∫∫ÈñãÊßçÔºåÁé©ÂÆ∂ ${players.find(p => p.id === hunterShotId)?.name} ‰πüÂá∫Â±Ä‰∫Ü„ÄÇ`);
    if (wolfKingShotId) showMessageWithTimeout(`ÁãºÁéãÈñãÊßçÔºåÁé©ÂÆ∂ ${players.find(p => p.id === wolfKingShotId)?.name} ‰πüÂá∫Â±Ä‰∫Ü„ÄÇ`);

    if (checkWerewolfWin(newPlayers)) return;

    setWerewolfState(prev => ({ ...prev, phase: 'day-end', votedOutPlayerId: eliminatedPlayerId, killedList: [] }));
  };

  // --- General UI Components ---
  const Home = () => (
    <div className="text-center p-4">
      <h2 className="text-3xl font-bold text-gray-800 mb-6">Ë´ãÈÅ∏ÊìáÈÅäÊà≤</h2>
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        {Object.keys(gameData).map(mode => (
          <button
            key={mode}
            onClick={() => setupGame(mode)}
            className="flex flex-col items-center p-6 bg-indigo-500 text-white rounded-3xl shadow-lg transition-transform hover:scale-105"
          >
            <span className="mb-2 text-5xl">{gameData[mode].icon}</span>
            <span className="text-xl font-bold">{gameData[mode].name}</span>
          </button>
        ))}
      </div>
      <div className="mt-8">
        <button
          onClick={() => setCurrentPage('history')}
          className="w-full py-3 px-6 bg-gray-200 text-gray-800 rounded-full font-bold shadow-md hover:bg-gray-300 transition"
        >
          <span className="inline-block mr-2">üìö</span>
          ÈÅäÊà≤Á¥ÄÈåÑ
        </button>
      </div>
    </div>
  );

  const Setup = () => (
    <div className="p-4 space-y-6">
      <div className="flex items-center justify-between">
        <button onClick={resetGame} className="text-gray-600 hover:text-gray-800 text-3xl">‚¨ÖÔ∏è</button>
        <h2 className="text-2xl font-bold text-gray-800">
          <span className="mr-2">{gameData[gameMode].icon}</span>
          {gameData[gameMode].name} Ë®≠ÂÆö
        </h2>
        <div className="w-8"></div>
      </div>
      {gameMode === 'whosTheSpy' && (
        <button
          onClick={fetchNewWords}
          disabled={isFetchingWords}
          className="w-full py-3 mt-4 bg-purple-500 text-white rounded-xl shadow-lg transition-all hover:bg-purple-600 disabled:bg-gray-400 disabled:cursor-not-allowed"
        >
          {isFetchingWords ? (
            <div className="flex justify-center items-center">
              <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
              ÁîüÊàê‰∏≠...
            </div>
          ) : (
            <>
              <span className="inline-block mr-2">‚ö°</span>
              ÂèñÂæóÊñ∞Ë©ûË™û
            </>
          )}
        </button>
      )}
      <div>
        <label className="block text-lg font-semibold mb-2 text-gray-700">ÈÅ∏ÊìáÁé©ÂÆ∂‰∫∫Êï∏</label>
        <select
          value={playerCount}
          onChange={(e) => {
            const newCount = parseInt(e.target.value);
            setPlayerCount(newCount);
            updateRoleCounts(gameMode, newCount);
          }}
          className="w-full p-3 rounded-xl border border-gray-300"
        >
          {Object.keys(gameData[gameMode].playerConfigs).map(num => (
            <option key={num} value={num}>{num} ‰∫∫</option>
          ))}
        </select>
      </div>
      <div>
        <label className="block text-lg font-semibold mb-2 text-gray-700">Ëá™ÂÆöÁæ©ËßíËâ≤</label>
        <div className="space-y-3">
          {gameData[gameMode].roles.map(role => (
            <div key={role.code} className="flex items-center justify-between p-3 bg-gray-100 rounded-xl">
              <div className="flex items-center">
                <span className="text-xl mr-2">{role.icon}</span>
                <span className="font-medium text-gray-700">{role.name}</span>
              </div>
              <input
                type="number"
                min="0"
                value={roleCounts[role.code] || 0}
                onChange={(e) => setRoleCounts(prev => ({ ...prev, [role.code]: parseInt(e.target.value) || 0 }))}
                className="w-16 text-center border rounded-lg"
              />
            </div>
          ))}
          <div className="flex items-center justify-between font-bold text-gray-800 mt-4">
            <span>Á∏Ω‰∫∫Êï∏:</span>
            <span>{Object.values(roleCounts).reduce((sum, count) => sum + count, 0)} / {playerCount}</span>
          </div>
        </div>
      </div>
      <button
        onClick={handleStartGame}
        className="w-full py-3 mt-6 bg-green-500 text-white rounded-xl shadow-lg transition-all hover:bg-green-600"
      >
        ÈñãÂßãÈÅäÊà≤
      </button>
    </div>
  );

  const RoleReveal = () => {
    const player = players[currentPlayerIndex];

    if (!player) return null;

    return (
      <div className="flex flex-col items-center justify-center p-4">
        <h2 className="text-2xl font-bold text-gray-800 mb-4">Ë´ãÂÇ≥Áµ¶‰∏ã‰∏Ä‰ΩçÁé©ÂÆ∂</h2>
        <div className="bg-white p-6 rounded-2xl shadow-xl w-full max-w-sm text-center">
          <p className="text-lg text-gray-600 mb-2">Ëº™Âà∞</p>
          <p className="text-4xl font-bold text-indigo-600">{player.name}</p>
          <div className="h-64 mt-4 relative">
            <div
              className={`relative w-full h-full transform-gpu transition-transform duration-500`}
              style={{ transformStyle: 'preserve-3d', transform: isCardFlipped ? 'rotateY(180deg)' : '' }}
            >
              {/* Card Front (Face down) */}
              <div
                onClick={() => setIsCardFlipped(true)}
                className="absolute inset-0 bg-indigo-500 rounded-2xl flex items-center justify-center p-4 cursor-pointer"
                style={{ backfaceVisibility: 'hidden' }}>
                <span className="text-white text-3xl font-bold">ÈªûÊìäÊü•ÁúãË∫´‰ªΩ</span>
              </div>
              {/* Card Back (Face up) */}
              <div
                className="absolute inset-0 bg-white rounded-2xl flex flex-col items-center justify-center p-4"
                style={{ backfaceVisibility: 'hidden', transform: 'rotateY(180deg)' }}>
                <div className="text-4xl text-indigo-500">
                  {gameData[gameMode].roles.find(r => r.code === player.role)?.icon}
                </div>
                <h3 className="text-xl font-bold mt-2 text-gray-800">{gameData[gameMode].roles.find(r => r.code === player.role)?.name}</h3>
                {gameMode === 'whosTheSpy' && (
                  <p className="text-md mt-2 text-gray-600">
                    Ë©ûË™û: <span className="font-semibold">{player.word === null ? 'ÁÑ°' : player.word}</span>
                  </p>
                )}
                <div className="mt-4 space-y-2">
                  <p className="text-xs text-gray-500">
                    {gameData[gameMode].roles.find(r => r.code === player.role)?.description}
                  </p>
                  {/* Avalon additional information */}
                  {gameMode === 'avalon' && (
                    <div className="text-xs text-center text-gray-500">
                      {/* Merlin */}
                      {player.role === 'merlin' && (
                        <p>ÈÇ™ÊÉ°ÊñπÊàêÂì°Ôºö<br />
                          {players.filter(p => gameData.avalon.roles.find(r => r.code === p.role)?.side === 'evil' && p.role !== 'mordred').map(p => p.name).join('„ÄÅ')}
                        </p>
                      )}
                      {/* Percival */}
                      {player.role === 'percival' && (
                        <p>Ê¢ÖÊûóÊàñËé´ÁîòÂ®úÔºö<br />
                          {players.filter(p => p.role === 'merlin' || p.role === 'morgana').map(p => p.name).join('„ÄÅ')}
                        </p>
                      )}
                      {/* Evil */}
                      {getPlayerRoleInfo(player.role)?.side === 'evil' && player.role !== 'oberon' && (
                        <p>ÈÇ™ÊÉ°Âêå‰º¥Ôºö<br />
                          {players.filter(p => p.id !== player.id && getPlayerRoleInfo(p.role)?.side === 'evil' && p.role !== 'oberon').map(p => p.name).join('„ÄÅ')}
                        </p>
                      )}
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>
        </div>
        <button
          onClick={nextPlayerReveal}
          className={`w-full max-w-sm py-3 mt-6 bg-green-500 text-white rounded-xl shadow-lg transition-all hover:bg-green-600 ${!isCardFlipped ? 'opacity-50 cursor-not-allowed' : ''}`}
          disabled={!isCardFlipped}
        >
          {currentPlayerIndex === players.length - 1 ? 'ÈñãÂßãÈÅäÊà≤' : `‰∏ã‰∏Ä‰ΩçÁé©ÂÆ∂ (${currentPlayerIndex + 1}/${players.length})`}
        </button>
      </div>
    );
  };

  const WhosTheSpyGameplay = () => {
    const alivePlayers = players.filter(p => p.alive);
    const currentPlayer = alivePlayers[whosTheSpyState.turn];

    const handleVote = () => {
      const radios = document.querySelectorAll('input[name="vote"]:checked');
      if (radios.length === 0) {
        showMessageWithTimeout('Ë´ãÈÅ∏Êìá‰∏Ä‰ΩçÁé©ÂÆ∂ÊäïÁ•®ÔºÅ');
        return;
      }
      processWhosTheSpyVote([parseInt(radios[0].value)]);
    };

    return (
      <div className="p-4 space-y-6">
        <h2 className="text-2xl font-bold text-gray-800 mb-4">
          <span className="inline-block mr-2">üëª</span>
          Ë™∞ÊòØËá•Â∫ï - Á¨¨ {whosTheSpyState.round} ÂõûÂêà
        </h2>

        <div className="bg-white p-4 rounded-xl shadow-md">
          <h3 className="text-lg font-bold mb-2">Â≠òÊ¥ªÁé©ÂÆ∂</h3>
          <div className="flex flex-wrap gap-2">
            {alivePlayers.map(p => (
              <span key={p.id} className="bg-gray-200 text-gray-800 text-sm font-semibold px-2 py-1 rounded-full">
                {p.name}
              </span>
            ))}
          </div>
        </div>

        {whosTheSpyState.phase === 'describing' && (
          <div className="bg-white p-4 rounded-xl shadow-md text-center">
            <h3 className="text-lg font-bold mb-2">ÁôºË®ÄÊôÇÈñì</h3>
            <p className="text-gray-600 mb-4">Ëº™Âà∞ <span className="text-indigo-600 font-bold">{currentPlayer?.name}</span> ÊèèËø∞„ÄÇ</p>
            <button onClick={nextWhosTheSpyTurn} className="w-full py-3 bg-green-500 text-white rounded-xl shadow-lg hover:bg-green-600">
              {whosTheSpyState.turn === alivePlayers.length - 1 ? 'ÁôºË®ÄÁµêÊùüÔºåÈñãÂßãÊäïÁ•®' : '‰∏ã‰∏Ä‰ΩçÁé©ÂÆ∂'}
            </button>
          </div>
        )}

        {whosTheSpyState.phase === 'voting' && (
          <div className="bg-white p-4 rounded-xl shadow-md">
            <h3 className="text-lg font-bold mb-2">ÊäïÁ•®Ê∑òÊ±∞</h3>
            <p className="text-gray-600 mb-4">Ë´ãÊâÄÊúâÁé©ÂÆ∂ÊäïÁ•®ÈÅ∏Âá∫‰Ω†Êá∑ÁñëÁöÑÂ∞çË±°„ÄÇ</p>
            <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
              {alivePlayers.map(player => (
                <div key={player.id} className="flex items-center space-x-2 p-2 bg-gray-100 rounded-lg">
                  <input type="radio" id={`vote-${player.id}`} name="vote" value={player.id} className="h-4 w-4 text-blue-600 focus:ring-blue-500" />
                  <label htmlFor={`vote-${player.id}`} className="text-lg font-medium text-gray-800">{player.name}</label>
                </div>
              ))}
            </div>
            <button onClick={handleVote} className="w-full py-3 mt-4 bg-red-500 text-white rounded-xl shadow-lg hover:bg-red-600">
              Á¢∫Ë™çÊäïÁ•®
            </button>
          </div>
        )}

        <button onClick={resetGame} className="w-full py-3 bg-gray-200 text-gray-800 rounded-xl shadow-md transition-all hover:bg-gray-300 mt-2">
          ËøîÂõûÈ¶ñÈ†Å
        </button>
      </div>
    );
  };

  const AvalonGameplay = () => {
    const isGoodWins = avalonState.questResults.filter(r => r === 'success').length === 3;
    const isEvilWins = avalonState.questResults.filter(r => r === 'fail').length === 3 || avalonState.failedVotes >= 5;
    const questSize = playerCount > 0 ? gameData.avalon.questSizes[playerCount][avalonState.currentQuest - 1] : 0;
    const currentLeader = players.find(p => p.id === avalonState.leader);

    const getOutcomeColor = (outcome) => {
      if (outcome === 'success') return 'bg-blue-500';
      if (outcome === 'fail') return 'bg-red-500';
      return 'bg-gray-400';
    };

    return (
      <div className="p-4 space-y-6">
        <div className="flex items-center justify-between mb-4">
          <button onClick={resetGame} className="text-gray-600 hover:text-gray-800 text-3xl">‚¨ÖÔ∏è</button>
          <h2 className="text-2xl font-bold text-gray-800">ÈòøÁì¶ÈöÜ</h2>
          <div className="w-8"></div>
        </div>

        {/* Scoreboard */}
        <div className="bg-white p-4 rounded-xl shadow-md">
          <h3 className="text-lg font-bold mb-2">‰ªªÂãôÈÄ≤Â∫¶</h3>
          <div className="flex justify-around items-center space-x-2">
            {[0, 1, 2, 3, 4].map(qIndex => (
              <button
                key={qIndex}
                onClick={() => avalonState.questTeams && avalonState.questTeams[qIndex] && showQuestTeamModal(qIndex)}
                className={`relative w-12 h-12 rounded-full flex flex-col items-center justify-center text-white font-bold transition-colors ${getOutcomeColor(avalonState.questResults[qIndex])}`}
              >
                {avalonState.questResults[qIndex] ? (
                  <>
                    <span className="text-xl">{gameData.avalon.questSizes[playerCount]?.[qIndex]}</span>
                    <span className="text-xs absolute bottom-1">{avalonState.questResults[qIndex] === 'success' ? 'ÊàêÂäü' : 'Â§±Êïó'}</span>
                  </>
                ) : (
                  <span className="text-xl">{gameData.avalon.questSizes[playerCount]?.[qIndex]}</span>
                )}
              </button>
            ))}
          </div>
          <p className="mt-4 text-center font-semibold text-gray-700">ÂúòÈöäÊäïÁ•®Â§±Êïó: {avalonState.failedVotes} / 5</p>
        </div>
        
        {/* Quest Team Modal */}
        {avalonState.showQuestTeamModal && (
          <div className="fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center z-50 p-4">
            <div className="bg-white p-6 rounded-2xl shadow-xl w-full max-w-sm text-center">
              <h3 className="text-2xl font-bold mb-4">
                Á¨¨ {avalonState.selectedQuestIndex + 1} Ê¨°‰ªªÂãôÂúòÈöä
              </h3>
              <ul className="space-y-2 text-lg">
                {avalonState.questTeams[avalonState.selectedQuestIndex].members.map(playerId => (
                  <li key={playerId} className="p-2 bg-gray-100 rounded-lg">{players.find(p => p.id === playerId)?.name}</li>
                ))}
              </ul>
              <button
                onClick={hideQuestTeamModal}
                className="w-full mt-6 py-3 bg-indigo-500 text-white rounded-xl hover:bg-indigo-600"
              >
                ÈóúÈñâ
              </button>
            </div>
          </div>
        )}

        {/* Game State */}
        {avalonState.currentVotePhase === 'assassination' && (
          <div className="bg-white p-4 rounded-xl shadow-md">
            <h3 className="text-lg font-bold mb-2 text-red-600 flex items-center">
              <span className="mr-2">üéØ</span>
              Âà∫ÂÆ¢Ë´ãÈÅ∏ÊìáÊ¢ÖÊûó
            </h3>
            <div className="grid grid-cols-3 gap-4">
              {players.filter(p => getPlayerRoleInfo(p.role)?.side === 'good').map(p => (
                <button
                  key={p.id}
                  onClick={() => assassinatePlayer(p.id)}
                  className={`p-2 rounded-lg text-center cursor-pointer border-2 transition-all hover:bg-red-200 ${avalonState.assassinationTarget === p.id ? 'bg-red-400 text-white border-red-500' : 'bg-gray-100 border-gray-300'}`}
                >
                  <span className="text-3xl">üë§</span>
                  <p className="font-semibold text-sm mt-1">{p.name}</p>
                </button>
              ))}
            </div>
          </div>
        )}

        {!(isGoodWins || isEvilWins) && (
          <>
            {/* Team Selection */}
            {avalonState.currentVotePhase === 'team-selection' && (
              <div className="bg-white p-4 rounded-xl shadow-md text-center">
                <p className="text-xl font-bold mb-2">
                  <span className="text-yellow-600 mr-2">È†òË¢ñ:</span> {currentLeader?.name}
                </p>
                <p className="text-lg font-bold text-gray-700">
                  <span className="text-blue-600 mr-2">‰ªªÂãô‰∫∫Êï∏:</span> {avalonState.team.length} / {questSize}
                </p>
                <div className="grid grid-cols-3 gap-4 my-4">
                  {players.map(p => {
                     const isLeader = avalonState.leader === p.id;
                     const onTeam = avalonState.team.includes(p.id);
                     let playerClass = 'bg-gray-100 border-gray-300';
                     if (onTeam) playerClass = 'bg-blue-400 text-white border-blue-500';
                     else if (isLeader) playerClass = 'bg-yellow-400 border-yellow-500';

                    return (
                        <button
                          key={p.id}
                          onClick={() => togglePlayerSelection(p.id)}
                          className={`p-2 rounded-lg text-center cursor-pointer border-2 transition-all ${playerClass}`}
                        >
                          {isLeader && <span className="text-xl">üëë</span>}
                          <span className="text-3xl">üë§</span>
                          <p className="font-semibold text-sm mt-1">{p.name}</p>
                        </button>
                    );
                  })}
                </div>
                <button
                  onClick={startAvalonTeamVote}
                  disabled={avalonState.team.length !== questSize}
                  className={`w-full py-3 mt-4 rounded-xl shadow-lg transition-all ${avalonState.team.length !== questSize ? 'bg-gray-400 cursor-not-allowed' : 'bg-green-500 text-white hover:bg-green-600'}`}
                >
                  ÁôºËµ∑ÊäïÁ•®
                </button>
              </div>
            )}
            
            {/* Team Voting */}
            {avalonState.currentVotePhase === 'team-voting' && (
              <div className="bg-white p-4 rounded-xl shadow-md text-center">
                <h3 className="text-lg font-bold mb-2">ÂúòÈöäÊäïÁ•®</h3>
                <p className="text-gray-500 text-sm mb-4">
                  Â∑≤ÊäïÁ•®‰∫∫Êï∏: {(avalonState.voteTally?.approve || 0) + (avalonState.voteTally?.reject || 0)} / {playerCount}
                </p>
                <div className="flex justify-center space-x-4">
                  <button onClick={() => recordAvalonTeamVote('approve')} className="p-4 rounded-xl bg-green-500 text-white hover:bg-green-600 transition-colors">
                    <span className="text-3xl">‚úÖ</span>
                    <p className="text-sm">ÈÄöÈÅé</p>
                  </button>
                  <button onClick={() => recordAvalonTeamVote('reject')} className="p-4 rounded-xl bg-red-500 text-white hover:bg-red-600 transition-colors">
                    <span className="text-3xl">‚ùå</span>
                    <p className="text-sm">‰∏çÈÄöÈÅé</p>
                  </button>
                </div>
              </div>
            )}
            
            {/* Mission Voting */}
            {avalonState.currentVotePhase === 'mission-voting' && (
                <div className="bg-white p-4 rounded-xl shadow-md text-center">
                    <h3 className="text-lg font-bold mb-2">‰ªªÂãôÊäïÁ•®</h3>
                    <p className="text-gray-500 text-sm mb-4">
                      Ë´ãÂèÉËàá‰ªªÂãôÁöÑÁé©ÂÆ∂ÈÅ∏Êìá„ÄåÊàêÂäü„ÄçÊàñ„ÄåÂ§±Êïó„Äç„ÄÇ
                    </p>
                    <p className="font-bold text-gray-700">
                        Â∑≤ÊäïÁ•®: {avalonState.missionVoteTally.success + avalonState.missionVoteTally.fail} / {avalonState.team.length}
                    </p>
                    <div className="flex justify-center space-x-4 mt-4">
                        <button onClick={() => recordAvalonMissionVote('success')} className="p-4 rounded-xl bg-blue-500 text-white hover:bg-blue-600 transition-colors">
                            <span className="text-3xl">üòä</span>
                            <p className="text-sm">ÊàêÂäü</p>
                        </button>
                        <button onClick={() => recordAvalonMissionVote('fail')} className="p-4 rounded-xl bg-red-500 text-white hover:bg-red-600 transition-colors">
                            <span className="text-3xl">üò†</span>
                            <p className="text-sm">Â§±Êïó</p>
                        </button>
                    </div>
                </div>
            )}

            {/* Mission Result */}
            {avalonState.currentVotePhase === 'mission-result' && (
                <div className="bg-white p-4 rounded-xl shadow-md text-center">
                    <h3 className="text-lg font-bold mb-2">‰ªªÂãôÁµêÊûú</h3>
                    <div className="flex justify-center space-x-4 mb-4">
                        <div className="flex items-center text-blue-600 font-bold">
                            <span className="mr-1">‚úÖ</span>ÊàêÂäü: {avalonState.missionVoteTally.success}
                        </div>
                        <div className="flex items-center text-red-600 font-bold">
                            <span className="mr-1">‚ùå</span>Â§±Êïó: {avalonState.missionVoteTally.fail}
                        </div>
                    </div>
                    <button onClick={advanceAvalonQuest} className="w-full py-3 mt-4 bg-green-500 text-white rounded-xl shadow-lg hover:bg-green-600">
                      ÈÄ≤ÂÖ•‰∏ã‰∏ÄÂõûÂêà
                    </button>
                </div>
            )}
          </>
        )}
      </div>
    );
  };

  const WerewolfGameplay = () => {
    const alivePlayers = players.filter(p => p.alive);
    const hasSeer = players.some(p => p.role === 'seer' && p.alive);
    const hasWitch = players.some(p => p.role === 'witch' && p.alive);
    const seer = players.find(p => p.role === 'seer' && p.alive);

    const handleVote = () => {
      const radios = document.querySelectorAll('input[name="vote"]:checked');
      if (radios.length === 0) {
        showMessageWithTimeout('Ë´ãÈÅ∏Êìá‰∏Ä‰ΩçÁé©ÂÆ∂ÊäïÁ•®ÔºÅ');
        return;
      }
      processWerewolfVote([parseInt(radios[0].value)]);
    };
    
    const IntroScreen = ({ title, description, nextPhase }) => (
      <div className="bg-white p-4 rounded-xl shadow-md text-center">
        <h3 className="text-lg font-bold mb-2">{title}</h3>
        <p className="text-gray-600">{description}</p>
        <button onClick={() => setWerewolfState(prev => ({ ...prev, phase: nextPhase }))} className="w-full py-3 mt-4 bg-indigo-500 text-white rounded-xl shadow-lg hover:bg-indigo-600">
            ÁπºÁ∫å
        </button>
      </div>
    );

    return (
        <div className="p-4 space-y-6">
            <h2 className="text-2xl font-bold text-gray-800">
                <span className="inline-block mr-2">ü™ì</span>
                Áãº‰∫∫ÊÆ∫ - Á¨¨ {werewolfState.day} {werewolfState.phase.startsWith('day') ? 'Â§©' : 'Â§ú'}
            </h2>
            
            <div className="bg-gray-800 text-white p-4 rounded-xl shadow-md">
              <h3 className="text-lg font-bold mb-2 flex items-center"><span className="mr-2">üíÄ</span>Ê≠ª‰∫°ÂêçÂñÆ</h3>
              <div className="flex flex-wrap gap-2">
                {players.filter(p => !p.alive).length > 0 ? (
                  players.filter(p => !p.alive).map(p => (
                    <span key={p.id} className="bg-red-500 text-white text-sm font-semibold px-2 py-1 rounded-full line-through">
                      {p.name} ({getPlayerRoleInfo(p.role)?.name})
                    </span>
                  ))
                ) : (
                  <p className="text-gray-400 text-sm">ÁõÆÂâçÂ∞öÁÑ°Áé©ÂÆ∂Âá∫Â±Ä„ÄÇ</p>
                )}
              </div>
            </div>

            {werewolfState.phase === 'night-intro' && <IntroScreen title="Â§úÊôöÈñãÂßã" description="Â§©ÈªëË´ãÈñâÁúº„ÄÇ" nextPhase="night-werewolves" />}
            
            {werewolfState.phase === 'night-werewolves' && (
                <div className="bg-white p-4 rounded-xl shadow-md text-center">
                    <h3 className="text-lg font-bold mb-2">Áãº‰∫∫Ë°åÂãï</h3>
                    <p className="text-gray-600">Áãº‰∫∫Ë´ãÁùúÁúºÔºå‰∏¶ÈÅ∏ÊìáË¶ÅÊÆ∫ÂÆ≥ÁöÑÁé©ÂÆ∂„ÄÇ</p>
                    <div className="grid grid-cols-2 md:grid-cols-3 gap-4 mt-4">
                        {alivePlayers.filter(p => getPlayerRoleInfo(p.role)?.side !== 'evil').map(p => (
                            <button key={p.id} onClick={() => handleWerewolfAction(p.id, 'werewolf')} className="p-2 rounded-lg bg-gray-100 border border-gray-300 text-gray-800 hover:bg-red-200">
                                <span className="text-3xl">üë§</span>
                                <p className="font-semibold text-sm mt-1">{p.name}</p>
                            </button>
                        ))}
                    </div>
                </div>
            )}

            {werewolfState.phase === 'night-seer-intro' && <IntroScreen title="Áãº‰∫∫Ë´ãÈñâÁúº" description="È†êË®ÄÂÆ∂Ë´ãÁùúÁúº„ÄÇ" nextPhase="night-seer" />}
            
            {werewolfState.phase === 'night-seer' && hasSeer && (
              <div className="bg-white p-4 rounded-xl shadow-md text-center">
                <h3 className="text-lg font-bold mb-2">È†êË®ÄÂÆ∂Ë°åÂãï</h3>
                <p className="text-gray-600">Ë´ãÈÅ∏ÊìáË¶ÅÊü•È©óÁöÑÁé©ÂÆ∂„ÄÇ</p>
                {werewolfState.seerResult ? (
                    <>
                        <div className="p-2 mt-4 bg-blue-100 rounded-lg text-blue-700 font-semibold">
                            {werewolfState.seerResult}
                        </div>
                        <button
                            onClick={() => setWerewolfState(prev => ({ ...prev, phase: 'night-witch-intro' }))}
                            className="w-full py-3 mt-4 bg-indigo-500 text-white rounded-xl shadow-lg hover:bg-indigo-600"
                        >
                            ÁπºÁ∫å
                        </button>
                    </>
                ) : (
                    <div className="grid grid-cols-2 md:grid-cols-3 gap-4 mt-4">
                        {alivePlayers.filter(p => p.id !== seer?.id).map(p => (
                            <button key={p.id} onClick={() => handleWerewolfAction(p.id, 'seer')} className="p-2 rounded-lg bg-gray-100 border border-gray-300 text-gray-800 hover:bg-blue-200">
                                <span className="text-3xl">üë§</span>
                                <p className="font-semibold text-sm mt-1">{p.name}</p>
                            </button>
                        ))}
                    </div>
                )}
              </div>
            )}
            
            {werewolfState.phase === 'night-seer' && !hasSeer && (
              <IntroScreen title="È†êË®ÄÂÆ∂Â∑≤Âá∫Â±Ä" description="Áõ¥Êé•ÈÄ≤ÂÖ•‰∏ã‰∏ÄÈöéÊÆµ„ÄÇ" nextPhase="night-witch-intro" />
            )}

            {werewolfState.phase === 'night-witch-intro' && <IntroScreen title="È†êË®ÄÂÆ∂Ë´ãÈñâÁúº" description="Â•≥Â∑´Ë´ãÁùúÁúº„ÄÇ" nextPhase="night-witch" />}

            {werewolfState.phase === 'night-witch' && hasWitch && (
              <div className="bg-white p-4 rounded-xl shadow-md text-center">
                <h3 className="text-lg font-bold mb-2">Â•≥Â∑´Ë°åÂãï</h3>
                <p className="text-gray-600">‰ªäÊôö <span className="text-red-600 font-bold">{players.find(p => p.id === werewolfState.werewolfTargetId)?.name}</span> Ë¢´ÊÆ∫ÂÆ≥‰∫Ü„ÄÇ</p>
                <div className="flex flex-col space-y-4 mt-4">
                  {werewolfState.witchHasAntidote && (
                    <button onClick={() => handleWerewolfAction(werewolfState.werewolfTargetId, 'witch-antidote')} className="w-full py-3 bg-blue-500 text-white rounded-xl shadow-lg hover:bg-blue-600">
                      <span className="inline-block mr-2">üõ°Ô∏è</span>
                      ‰ΩøÁî®Ëß£Ëó•
                    </button>
                  )}
                  {werewolfState.witchHasPoison && (
                    <div className="w-full">
                      <p className="text-gray-500 mb-2">ÊàñÈÅ∏ÊìáÊØíÊÆ∫Â∞çË±°:</p>
                      <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
                        {alivePlayers.filter(p => p.id !== werewolfState.werewolfTargetId).map(p => (
                          <button key={p.id} onClick={() => handleWerewolfAction(p.id, 'witch-poison')} className="p-2 rounded-lg bg-gray-100 border border-gray-300 text-gray-800 hover:bg-purple-200">
                            <span className="inline-block mr-2 text-purple-600">üíÄ</span>
                            {p.name}
                          </button>
                        ))}
                      </div>
                    </div>
                  )}
                  <button onClick={() => setWerewolfState(prev => ({ ...prev, phase: 'night-end' }))} className="w-full py-3 bg-gray-200 text-gray-800 rounded-xl shadow-md hover:bg-gray-300">
                    ‰∏ç‰ΩøÁî®Ëó•Âäë
                  </button>
                </div>
              </div>
            )}
            
            {werewolfState.phase === 'night-witch' && !hasWitch && (
              <IntroScreen title="Â•≥Â∑´Â∑≤Âá∫Â±Ä" description="Áõ¥Êé•ÈÄ≤ÂÖ•‰∏ã‰∏ÄÈöéÊÆµ„ÄÇ" nextPhase="night-end" />
            )}
            
            {werewolfState.phase === 'night-end' && (
                <div className="bg-white p-4 rounded-xl shadow-md text-center">
                    <h3 className="text-lg font-bold mb-2">Â§úÊôöÁµêÊùü</h3>
                    <p className="text-gray-600">Â§©‰∫Æ‰∫ÜÔºåË´ã‰∏ªÊåÅ‰∫∫ÈªûÊìäÊåâÈàïÁµêÊùüÂ§úÊôö„ÄÇ</p>
                    <button onClick={endNight} className="w-full py-3 mt-4 bg-green-500 text-white rounded-xl shadow-lg hover:bg-green-600">
                        Â§©‰∫Æ‰∫ÜÔºåÊè≠ÊõâÁµêÊûú
                    </button>
                </div>
            )}

            {werewolfState.phase === 'day-announcement' && (
                <div className="bg-white p-4 rounded-xl shadow-md text-center">
                    <h3 className="text-lg font-bold mb-2">ÁôΩÂ§©ÂÆ£Âëä</h3>
                    {werewolfState.killedList.length > 0 ? (
                        <>
                            <p className="text-gray-600 font-bold">Êò®ÊôöÂá∫Â±ÄÁöÑÁé©ÂÆ∂ÊúâÔºö</p>
                            <ul className="mt-2 space-y-1">
                                {werewolfState.killedList.map(playerId => (
                                    <li key={playerId} className="text-red-600 text-lg font-bold">
                                        {players.find(p => p.id === playerId)?.name}
                                    </li>
                                ))}
                            </ul>
                            <button onClick={startDayDiscussion} className="w-full py-3 mt-4 bg-indigo-500 text-white rounded-xl shadow-lg hover:bg-indigo-600">
                                ÈñãÂßãÁôΩÂ§©Ë®éË´ñ
                            </button>
                        </>
                    ) : (
                        <>
                            <p className="text-gray-600 font-bold">Êò®ÊôöÊòØÂÄãÂπ≥ÂÆâÂ§úÔºåÊ≤íÊúâ‰∫∫Âá∫Â±Ä„ÄÇ</p>
                            <button onClick={startDayDiscussion} className="w-full py-3 mt-4 bg-indigo-500 text-white rounded-xl shadow-lg hover:bg-indigo-600">
                                ÈñãÂßãÁôΩÂ§©Ë®éË´ñ
                            </button>
                        </>
                    )}
                </div>
            )}

            {werewolfState.phase === 'day-discussion' && (
              <div className="bg-white p-4 rounded-xl shadow-md text-center">
                <h3 className="text-lg font-bold mb-2">ÁôΩÂ§©Ë®éË´ñÈöéÊÆµ</h3>
                <p className="text-gray-600 mb-4">Ë´ãÊâÄÊúâÁé©ÂÆ∂ÁôºË®ÄÔºåË®éË´ñË™∞ÊòØÁãº‰∫∫„ÄÇ</p>
                <button onClick={startDayVoting} className="w-full py-3 mt-4 bg-red-500 text-white rounded-xl shadow-lg hover:bg-red-600">
                  ÈñãÂßãÊîæÈÄêÊäïÁ•®
                </button>
              </div>
            )}
            
            {werewolfState.phase === 'day-voting' && (
                <div className="bg-white p-4 rounded-xl shadow-md text-center">
                    <h3 className="text-lg font-bold mb-2">ÊîæÈÄêÊäïÁ•®</h3>
                    <p className="text-gray-600 mb-4">Ë´ãÊâÄÊúâÂ≠òÊ¥ªÁé©ÂÆ∂ÊäïÁ•®ÈÅ∏Âá∫‰Ω†Êá∑ÁñëÁöÑÂ∞çË±°„ÄÇ</p>
                    <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
                        {alivePlayers.map(p => (
                            <div key={p.id} className="flex items-center space-x-2 p-2 bg-gray-100 rounded-lg">
                                <input type="radio" id={`vote-${p.id}`} name="vote" value={p.id} className="h-4 w-4 text-blue-600 focus:ring-blue-500" />
                                <label htmlFor={`vote-${p.id}`} className="text-lg font-medium text-gray-800">{p.name}</label>
                            </div>
                        ))}
                    </div>
                    <button onClick={handleVote} className="w-full py-3 mt-4 bg-red-500 text-white rounded-xl shadow-lg hover:bg-red-600">
                        Á¢∫Ë™çÊäïÁ•®
                    </button>
                </div>
            )}

            {werewolfState.phase === 'day-end' && (
                <div className="bg-white p-4 rounded-xl shadow-md text-center">
                    <h3 className="text-lg font-bold mb-2">ÁôΩÂ§©ÁµêÊùü</h3>
                    <p className="text-gray-600 mb-4">
                        {werewolfState.votedOutPlayerId !== null
                            ? `Á∂ìÈÅéÊäïÁ•®ÔºåÁé©ÂÆ∂ ${players.find(p => p.id === werewolfState.votedOutPlayerId)?.name} Â∑≤Ë¢´ÊîæÈÄê„ÄÇ`
                            : `ÊäïÁ•®ÂæåÁÑ°‰∫∫Âá∫Â±Ä„ÄÇ`
                        }
                    </p>
                    <button 
                        onClick={() => setWerewolfState(prev => ({ ...prev, phase: 'night-intro', votedOutPlayerId: null }))} 
                        className="w-full py-3 mt-4 bg-gray-700 text-white rounded-xl shadow-lg hover:bg-black"
                    >
                        ÈÄ≤ÂÖ•Â§úÊôö
                    </button>
                </div>
            )}
            
            <button onClick={resetGame} className="w-full py-3 bg-gray-200 text-gray-800 rounded-xl shadow-md transition-all hover:bg-gray-300 mt-2">
              ËøîÂõûÈ¶ñÈ†Å
            </button>
        </div>
    );
  };
  
  const History = () => (
    <div className="p-4 space-y-6">
      <div className="flex items-center justify-between">
        <button onClick={resetGame} className="text-gray-600 hover:text-gray-800 text-3xl">‚¨ÖÔ∏è</button>
        <h2 className="text-2xl font-bold text-gray-800">ÈÅäÊà≤Á¥ÄÈåÑ</h2>
        <div className="w-8"></div>
      </div>
      {gameHistory.length === 0 ? (
        <p className="text-center text-gray-500 mt-8">ÁõÆÂâçÊ≤íÊúâÈÅäÊà≤Á¥ÄÈåÑ„ÄÇ</p>
      ) : (
        gameHistory.map((entry, index) => (
          <div key={index} className="bg-white p-6 rounded-2xl shadow-md space-y-2">
            <div className="flex items-center justify-between font-bold text-gray-800">
              <span>{entry.gameMode}</span>
              <span>{entry.timestamp}</span>
            </div>
            <ul className="text-sm text-gray-600 space-y-1">
              {entry.players.map((p, i) => (
                <li key={i}>{p.name}: {p.role}</li>
              ))}
            </ul>
            <p className="text-right text-sm font-bold mt-2">ÁµêÊûú: {entry.result}</p>
          </div>
        ))
      )}
    </div>
  );
  
  const ResultScreen = () => {
    const getStatusText = (isAlive) => isAlive ? 'Â≠òÊ¥ª' : 'Â∑≤Âá∫Â±Ä';
    const getStatusIcon = (isAlive) => isAlive ? '‚ù§Ô∏è' : 'üíÄ';
    const gameTitle = gameData[gameMode]?.name;
    
    const isGoodWin = gameResult.includes('Ê≠£Áæ©') || gameResult.includes('Âπ≥Ê∞ë') || gameResult.includes('Â•Ω‰∫∫');
    const isEvilWin = gameResult.includes('ÈÇ™ÊÉ°') || gameResult.includes('Ëá•Â∫ï') || gameResult.includes('Áãº‰∫∫');

    return (
        <div className="p-4 space-y-6 text-center">
            <h2 className="text-3xl font-bold text-gray-800 flex items-center justify-center">
                <span className="mr-2">üèÜ</span>
                ÈÅäÊà≤ÁµêÁÆó
            </h2>
            <h3 className={`text-2xl font-bold ${isGoodWin ? 'text-blue-600' : isEvilWin ? 'text-red-600' : 'text-gray-700'}`}>
              {gameResult || `${gameTitle} ÈÅäÊà≤ÁµêÊùü`}
            </h3>
            <div className="bg-white p-6 rounded-2xl shadow-xl">
                <h4 className="text-lg font-bold mb-4">Áé©ÂÆ∂ÊúÄÁµÇÁãÄÊÖã</h4>
                <ul className="space-y-4 text-left">
                    {players.map(p => {
                      const roleInfo = getPlayerRoleInfo(p.role);
                      let borderColor = '#e5e7eb';
                      let bgColor = '#f3f4f6';
                      let statusColor = 'text-gray-600';

                      if (gameMode === 'avalon') {
                        if (roleInfo?.side === 'good') {
                            borderColor = '#3b82f6'; bgColor = '#dbeafe';
                        } else if (roleInfo?.side === 'evil') {
                            borderColor = '#ef4444'; bgColor = '#fee2e2';
                        }
                      } else {
                        borderColor = p.alive ? '#4ade80' : '#f87171';
                        bgColor = p.alive ? '#dcfce7' : '#fee2e2';
                        statusColor = p.alive ? 'text-green-600' : 'text-red-600';
                      }

                      return (
                        <li key={p.id} className="flex items-center justify-between p-3 rounded-lg border-2" style={{ borderColor, backgroundColor: bgColor }}>
                            <div className="flex flex-col">
                                <span className="text-lg font-bold text-gray-800">{p.name}</span>
                                <span className="text-sm text-gray-600">
                                    Ë∫´ÂàÜ: <span className="font-semibold">{roleInfo?.name}</span>
                                    {gameMode === 'whosTheSpy' && p.word && (
                                      <span className="ml-2">({p.word})</span>
                                    )}
                                </span>
                            </div>
                            {gameMode !== 'avalon' && (
                              <div className={`flex items-center text-sm font-bold ${statusColor}`}>
                                  <span className="inline-block mr-1">{getStatusIcon(p.alive)}</span>
                                  {getStatusText(p.alive)}
                              </div>
                            )}
                        </li>
                      );
                    })}
                </ul>
            </div>
            <button onClick={resetGame} className="w-full py-3 bg-indigo-500 text-white rounded-xl shadow-lg hover:bg-indigo-600 transition">
                ËøîÂõû‰∏ªÈÅ∏ÂñÆ
            </button>
        </div>
    );
  };


  const resetGame = () => {
    setCurrentPage('home');
    setGameMode(null);
    setPlayers([]);
    setRoleCounts({});
    setPlayerCount(0);
    setCurrentPlayerIndex(0);
    setIsCardFlipped(false);
    setGameResult('');
    setAvalonState({
      leader: null,
      currentQuest: 0,
      team: [],
      questResults: [],
      voteCount: 0,
      currentVotePhase: 'team-selection',
      questVoteOutcome: null,
      missionVoteTally: { success: 0, fail: 0 },
      assassinationTarget: null,
      failedVotes: 0,
      questTeams: [],
      showQuestTeamModal: false,
      selectedQuestIndex: null
    });
    setWhosTheSpyState({ round: 1, turn: 0, descriptions: {}, phase: 'describing' });
    setWerewolfState({ day: 1, phase: 'night-intro', killedPlayerId: null, poisonedPlayerId: null, savedPlayerId: null, werewolfTargetId: null, seerTargetId: null, seerResult: null, guardianTargetId: null, killedList: [], playersToVote: [], votedOutPlayerId: null });
  };
  
  const fetchNewWords = async () => {
    setIsFetchingWords(true);
    showMessageWithTimeout('Ê≠£Âú®ÂèñÂæóÊñ∞Ë©ûË™û...');
    const prompt = "Generate 5 pairs of related words suitable for the 'Who's the Spy' game in Traditional Chinese. Each pair should consist of two words that are similar but not identical. The output should be a JSON array of arrays, like [['word1', 'word2'], ['word3', 'word4'], ...]. The words should be common nouns.";
    const apiKey = "AIzaSyCEIsgA8IDtFfJX1sNNv48xnm1TTYKInm4";
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

    const payload = {
        contents: [{ parts: [{ text: prompt }] }],
        generationConfig: {
            responseMimeType: "application/json",
            responseSchema: {
                type: "ARRAY",
                items: {
                    type: "ARRAY",
                    items: { "type": "STRING" },
                    minItems: 2,
                    maxItems: 2
                },
                minItems: 5,
                maxItems: 5
            }
        }
    };

    try {
        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
        const result = await response.json();
        const jsonText = result?.candidates?.[0]?.content?.parts?.[0]?.text;
        const newWords = JSON.parse(jsonText);

        if (Array.isArray(newWords) && newWords.length > 0) {
            gameData.whosTheSpy.words = newWords;
            showMessageWithTimeout('ÊàêÂäüÂèñÂæóÊñ∞Ë©ûË™ûÔºÅ');
        } else {
            showMessageWithTimeout('ÂèñÂæóË©ûË™ûÂ§±ÊïóÔºåË´ãÁ®çÂæåÂÜçË©¶„ÄÇ');
        }
    } catch (error) {
        console.error("Failed to fetch new words:", error);
        showMessageWithTimeout('ÈÄ£Á∑öÈåØË™§ÔºåÁÑ°Ê≥ïÂèñÂæóÊñ∞Ë©ûË™û„ÄÇË´ãÊ™¢Êü•Á∂≤Ë∑ØÈÄ£Á∑ö„ÄÇ');
    } finally {
        setIsFetchingWords(false);
    }
  };


  return (
    <div className="font-sans antialiased bg-gray-100 min-h-screen flex items-center justify-center p-4">
      <div className="bg-white rounded-3xl shadow-2xl p-6 md:p-10 w-full max-w-lg text-center transform transition-all duration-300">
        <header className="mb-8">
          <h1 className="text-4xl md:text-5xl font-extrabold text-indigo-600">
            <span className="inline-block mr-2 text-5xl">üéÆ</span>
            Ê°åÈÅäÂä©Êâã
          </h1>
          <p className="mt-2 text-gray-500 text-lg">ÂñÆÊ©üÁâà</p>
        </header>
        <div className="relative">
          {message && (
            <div className="absolute top-0 left-1/2 -translate-x-1/2 z-50 p-3 bg-red-500 text-white rounded-lg shadow-xl text-center transition-all duration-300">
              {message}
            </div>
          )}
        </div>
        <div className="animate-fade-in">
          {currentPage === 'home' && <Home />}
          {currentPage === 'setup' && <Setup />}
          {currentPage === 'role-reveal' && <RoleReveal />}
          {currentPage === 'whos-the-spy-gameplay' && <WhosTheSpyGameplay />}
          {currentPage === 'avalon-gameplay' && <AvalonGameplay />}
          {currentPage === 'werewolf-gameplay' && <WerewolfGameplay />}
          {currentPage === 'history' && <History />}
          {currentPage === 'result-screen' && <ResultScreen />}
        </div>
      </div>
    </div>
  );
};

ReactDOM.render(<App />, document.getElementById('root'));

